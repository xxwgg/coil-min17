{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An image loading library for Android backed by Kotlin Coroutines. Coil is: Fast : Coil performs a number of optimizations including memory and disk caching, downsampling the image in memory, re-using bitmaps, automatically pausing/cancelling requests, and more. Lightweight : Coil adds ~2000 methods to your APK (for apps that already use OkHttp and Coroutines), which is comparable to Picasso and significantly less than Glide and Fresco. Easy to use : Coil's API leverages Kotlin's language features for simplicity and minimal boilerplate. Modern : Coil is Kotlin-first and uses modern libraries including Coroutines, OkHttp, Okio, and AndroidX Lifecycles. Coil is an acronym for: Co routine I mage L oader. Made with \u2764\ufe0f at Instacart . Translations: \ud55c\uad6d\uc5b4 , \u4e2d\u6587 Download \u00b6 Coil is available on mavenCentral() . implementation ( \"io.coil-kt:coil:1.3.0\" ) Quick Start \u00b6 To load an image into an ImageView , use the load extension function: // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests can be configured with an optional trailing lambda: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } Image Loaders \u00b6 imageView.load uses the singleton ImageLoader to enqueue an ImageRequest . The singleton ImageLoader can be accessed using an extension function: val imageLoader = context . imageLoader Optionally, you can create your own ImageLoader instance(s) and inject them with dependency injection: val imageLoader = ImageLoader ( context ) If you do not want the singleton ImageLoader , depend on io.coil-kt:coil-base . Requests \u00b6 To load an image into a custom target, enqueue an ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () val disposable = imageLoader . enqueue ( request ) To load an image imperatively, execute an ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable Requirements \u00b6 AndroidX Min SDK 14+ Java 8+ R8 / Proguard \u00b6 Coil is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for Coroutines , OkHttp and Okio . License \u00b6 Copyright 2021 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#download","text":"Coil is available on mavenCentral() . implementation ( \"io.coil-kt:coil:1.3.0\" )","title":"Download"},{"location":"#quick-start","text":"To load an image into an ImageView , use the load extension function: // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests can be configured with an optional trailing lambda: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) }","title":"Quick Start"},{"location":"#image-loaders","text":"imageView.load uses the singleton ImageLoader to enqueue an ImageRequest . The singleton ImageLoader can be accessed using an extension function: val imageLoader = context . imageLoader Optionally, you can create your own ImageLoader instance(s) and inject them with dependency injection: val imageLoader = ImageLoader ( context ) If you do not want the singleton ImageLoader , depend on io.coil-kt:coil-base .","title":"Image Loaders"},{"location":"#requests","text":"To load an image into a custom target, enqueue an ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target { drawable -> // Handle the result. } . build () val disposable = imageLoader . enqueue ( request ) To load an image imperatively, execute an ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val drawable = imageLoader . execute ( request ). drawable","title":"Requests"},{"location":"#requirements","text":"AndroidX Min SDK 14+ Java 8+","title":"Requirements"},{"location":"#r8-proguard","text":"Coil is fully compatible with R8 out of the box and doesn't require adding any extra rules. If you use Proguard, you may need to add rules for Coroutines , OkHttp and Okio .","title":"R8 / Proguard"},{"location":"#license","text":"Copyright 2021 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"README-ko/","text":"Coil\uc740 Kotlin Coroutines\uc73c\ub85c \ub9cc\ub4e4\uc5b4\uc9c4 Android \ubc31\uc564\ub4dc \uc774\ubbf8\uc9c0 \ub85c\ub529 \ub77c\uc774\ube0c\ub7ec\ub9ac\uc785\ub2c8\ub2e4. Coil \uc740: \ube60\ub974\ub2e4 : Coil\uc740 \uba54\ubaa8\ub9ac\uc640 \ub514\uc2a4\ud06c\uc758 \uce90\uc2f1, \uba54\ubaa8\ub9ac\uc758 \uc774\ubbf8\uc9c0 \ub2e4\uc6b4 \uc0d8\ud50c\ub9c1, Bitmap \uc7ac\uc0ac\uc6a9, \uc77c\uc2dc\uc815\uc9c0/\ucde8\uc18c\uc758 \uc790\ub3d9\ud654 \ub4f1\ub4f1 \uc218 \ub9ce\uc740 \ucd5c\uc801\ud654 \uc791\uc5c5\uc744 \uc218\ud589\ud569\ub2c8\ub2e4. \uac00\ubccd\ub2e4 : Coil\uc740 \ucd5c\ub300 2000\uac1c\uc758 method\ub4e4\uc744 APK\uc5d0 \ucd94\uac00\ud569\ub2c8\ub2e4(\uc774\ubbf8 OkHttp\uc640 Coroutines\uc744 \uc0ac\uc6a9\uc911\uc778 \uc571\uc5d0 \ud55c\ud558\uc5ec), \uc774\ub294 Picasso \ube44\uc2b7\ud55c \uc218\uc900\uc774\uba70 Glide\uc640 Fresco\ubcf4\ub2e4\ub294 \uc801\uc2b5\ub2c8\ub2e4. \uc0ac\uc6a9\ud558\uae30 \uc27d\ub2e4 : Coil API\ub294 \uc2ec\ud50c\ud568\uacfc \ucd5c\uc18c\ud55c\uc758 boilerplate\ub97c \uc704\ud558\uc5ec Kotlin\uc758 \uae30\ub2a5\uc744 \ud65c\uc6a9\ud569\ub2c8\ub2e4. \ud604\ub300\uc801\uc774\ub2e4 : Coil\uc740 Kotlin \uc6b0\uc120\uc774\uba70 Coroutines, OkHttp, Okio, AndroidX Lifecycles\ub4f1\uc758 \ucd5c\uc2e0 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. Coil\uc740: Co routine I mage L oader\uc758 \uc57d\uc790\uc785\ub2c8\ub2e4. \u2764\ufe0f Instacart \uc5d0\uc11c \u2764\ufe0f\uc73c\ub85c \ub9cc\ub4e4\uc5c8\uc2b5\ub2c8\ub2e4. \ub2e4\uc6b4\ub85c\ub4dc \u00b6 Coil\uc740 mavenCentral() \ub85c \uc774\uc6a9 \uac00\ub2a5\ud569\ub2c8\ub2e4. implementation ( \"io.coil-kt:coil:1.3.0\" ) \ube60\ub978 \uc2dc\uc791 \u00b6 ImageView \ub85c \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\uae30 \uc704\ud574, load \ud655\uc7a5 \ud568\uc218\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests\ub294 trailing lambda \uc2dd\uc744 \uc774\uc6a9\ud558\uc5ec \ucd94\uac00 \uc124\uc815\uc744 \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } \uc5ec\uae30\uc11c Coil\uc758 \uc804\uccb4 \ubb38\uc11c \ub97c \ud655\uc778\ud558\uc138\uc694. \uc694\uad6c\uc0ac\ud56d \u00b6 AndroidX Min SDK 14+ Java 8+ R8 / Proguard \u00b6 Coil\uc740 \ubcc4\ub3c4\uc758 \uc124\uc815 \uc5c6\uc774 R8\uacfc \uc644\ubcbd\ud558\uac8c \ud638\ud658 \uac00\ub2a5\ud558\uba70 \ucd94\uac00 \uaddc\uce59\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. Proguard\ub97c \uc0ac\uc6a9\ud560 \uacbd\uc6b0, Coroutines , OkHttp , Okio \uc5d0 \uaddc\uce59\uc744 \ucd94\uac00\ud560 \ud544\uc694\uac00 \uc788\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \ub77c\uc774\uc120\uc2a4 \u00b6 Copyright 2021 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"README ko"},{"location":"README-ko/#_1","text":"Coil\uc740 mavenCentral() \ub85c \uc774\uc6a9 \uac00\ub2a5\ud569\ub2c8\ub2e4. implementation ( \"io.coil-kt:coil:1.3.0\" )","title":"\ub2e4\uc6b4\ub85c\ub4dc"},{"location":"README-ko/#_2","text":"ImageView \ub85c \uc774\ubbf8\uc9c0\ub97c \ubd88\ub7ec\uc624\uae30 \uc704\ud574, load \ud655\uc7a5 \ud568\uc218\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... Requests\ub294 trailing lambda \uc2dd\uc744 \uc774\uc6a9\ud558\uc5ec \ucd94\uac00 \uc124\uc815\uc744 \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } \uc5ec\uae30\uc11c Coil\uc758 \uc804\uccb4 \ubb38\uc11c \ub97c \ud655\uc778\ud558\uc138\uc694.","title":"\ube60\ub978 \uc2dc\uc791"},{"location":"README-ko/#_3","text":"AndroidX Min SDK 14+ Java 8+","title":"\uc694\uad6c\uc0ac\ud56d"},{"location":"README-ko/#r8-proguard","text":"Coil\uc740 \ubcc4\ub3c4\uc758 \uc124\uc815 \uc5c6\uc774 R8\uacfc \uc644\ubcbd\ud558\uac8c \ud638\ud658 \uac00\ub2a5\ud558\uba70 \ucd94\uac00 \uaddc\uce59\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. Proguard\ub97c \uc0ac\uc6a9\ud560 \uacbd\uc6b0, Coroutines , OkHttp , Okio \uc5d0 \uaddc\uce59\uc744 \ucd94\uac00\ud560 \ud544\uc694\uac00 \uc788\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4.","title":"R8 / Proguard"},{"location":"README-ko/#_4","text":"Copyright 2021 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"\ub77c\uc774\uc120\uc2a4"},{"location":"README-zh/","text":"Coil \u662f\u4e00\u4e2a Android \u56fe\u7247\u52a0\u8f7d\u5e93\uff0c\u901a\u8fc7 Kotlin \u534f\u7a0b\u7684\u65b9\u5f0f\u52a0\u8f7d\u56fe\u7247\u3002\u7279\u70b9\u5982\u4e0b\uff1a \u66f4\u5feb : Coil \u5728\u6027\u80fd\u4e0a\u6709\u5f88\u591a\u4f18\u5316\uff0c\u5305\u62ec\u5185\u5b58\u7f13\u5b58\u548c\u78c1\u76d8\u7f13\u5b58\uff0c\u628a\u7f29\u7565\u56fe\u5b58\u4fdd\u5b58\u5728\u5185\u5b58\u4e2d\uff0c\u5faa\u73af\u5229\u7528 bitmap\uff0c\u81ea\u52a8\u6682\u505c\u548c\u53d6\u6d88\u56fe\u7247\u7f51\u7edc\u8bf7\u6c42\u7b49\u3002 \u66f4\u8f7b\u91cf\u7ea7 : Coil \u53ea\u67092000\u4e2a\u65b9\u6cd5\uff08\u524d\u63d0\u662f\u4f60\u7684 APP \u91cc\u9762\u96c6\u6210\u4e86 OkHttp \u548c Coroutines\uff09\uff0cCoil \u548c Picasso \u7684\u65b9\u6cd5\u6570\u5dee\u4e0d\u591a\uff0c\u76f8\u6bd4 Glide \u548c Fresco \u8981\u8f7b\u91cf\u5f88\u591a\u3002 \u66f4\u5bb9\u6613\u4f7f\u7528 : Coil \u7684 API \u5145\u5206\u5229\u7528\u4e86 Kotlin \u8bed\u8a00\u7684\u65b0\u7279\u6027\uff0c\u7b80\u5316\u548c\u51cf\u5c11\u4e86\u5f88\u591a\u6837\u677f\u4ee3\u7801\u3002 \u66f4\u6d41\u884c : Coil \u9996\u9009 Kotlin \u8bed\u8a00\u5f00\u53d1\u5e76\u4e14\u4f7f\u7528\u5305\u542b Coroutines, OkHttp, Okio \u548c AndroidX Lifecycles \u5728\u5185\u6700\u6d41\u884c\u7684\u5f00\u6e90\u5e93\u3002 Coil \u540d\u5b57\u7684\u7531\u6765\uff1a\u53d6 Co routine I mage L oader \u9996\u5b57\u6bcd\u5f97\u6765\u3002 \u5728 Instacart \u7528\u2764\ufe0f\u6253\u9020\u3002 \u4e0b\u8f7d \u00b6 Coil \u53ef\u4ee5\u5728 mavenCentral() \u4e0b\u8f7d implementation ( \"io.coil-kt:coil:1.3.0\" ) \u5feb\u901f\u4e0a\u624b \u00b6 \u53ef\u4ee5\u4f7f\u7528 ImageView \u7684\u6269\u5c55\u51fd\u6570 load \u52a0\u8f7d\u4e00\u5f20\u56fe\u7247\uff1a // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... \u53ef\u4ee5\u4f7f\u7528 lambda \u8bed\u6cd5\u8f7b\u677e\u914d\u7f6e\u8bf7\u6c42\u9009\u9879\uff1a imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } \u4e5f\u53ef\u4ee5\u67e5\u770b Coil \u7684 \u5b8c\u6574\u6587\u6863 \u83b7\u5f97\u66f4\u591a\u4fe1\u606f\u3002 \u73af\u5883\u8981\u6c42 \u00b6 AndroidX Min SDK 14+ Java 8+ R8 / Proguard \u00b6 Coil \u517c\u5bb9 R8 \u6df7\u6dc6\uff0c\u60a8\u65e0\u9700\u518d\u6dfb\u52a0\u5176\u4ed6\u7684\u89c4\u5219 \u5982\u679c\u60a8\u9700\u8981\u6df7\u6dc6\u4ee3\u7801\uff0c\u53ef\u80fd\u9700\u8981\u6dfb\u52a0\u5bf9\u5e94\u7684\u6df7\u6dc6\u89c4\u5219\uff1a Coroutines , OkHttp , Okio \u3002 License \u00b6 Copyright 2021 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"README zh"},{"location":"README-zh/#_1","text":"Coil \u53ef\u4ee5\u5728 mavenCentral() \u4e0b\u8f7d implementation ( \"io.coil-kt:coil:1.3.0\" )","title":"\u4e0b\u8f7d"},{"location":"README-zh/#_2","text":"\u53ef\u4ee5\u4f7f\u7528 ImageView \u7684\u6269\u5c55\u51fd\u6570 load \u52a0\u8f7d\u4e00\u5f20\u56fe\u7247\uff1a // URL imageView . load ( \"https://www.example.com/image.jpg\" ) // Resource imageView . load ( R . drawable . image ) // File imageView . load ( File ( \"/path/to/image.jpg\" )) // And more... \u53ef\u4ee5\u4f7f\u7528 lambda \u8bed\u6cd5\u8f7b\u677e\u914d\u7f6e\u8bf7\u6c42\u9009\u9879\uff1a imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } \u4e5f\u53ef\u4ee5\u67e5\u770b Coil \u7684 \u5b8c\u6574\u6587\u6863 \u83b7\u5f97\u66f4\u591a\u4fe1\u606f\u3002","title":"\u5feb\u901f\u4e0a\u624b"},{"location":"README-zh/#_3","text":"AndroidX Min SDK 14+ Java 8+","title":"\u73af\u5883\u8981\u6c42"},{"location":"README-zh/#r8-proguard","text":"Coil \u517c\u5bb9 R8 \u6df7\u6dc6\uff0c\u60a8\u65e0\u9700\u518d\u6dfb\u52a0\u5176\u4ed6\u7684\u89c4\u5219 \u5982\u679c\u60a8\u9700\u8981\u6df7\u6dc6\u4ee3\u7801\uff0c\u53ef\u80fd\u9700\u8981\u6dfb\u52a0\u5bf9\u5e94\u7684\u6df7\u6dc6\u89c4\u5219\uff1a Coroutines , OkHttp , Okio \u3002","title":"R8 / Proguard"},{"location":"README-zh/#license","text":"Copyright 2021 Coil Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 [1.3.0] - July 10, 2021 \u00b6 New : Add support for Jetpack Compose . It's based on Accompanist 's Coil integration, but has a number of changes. Check out the docs for more info. Add allowConversionToBitmap to enable/disable the automatic bitmap conversion for Transformation s. ( #775 ) Add enforceMinimumFrameDelay to ImageDecoderDecoder and GifDecoder to enable rewriting a GIF's frame delay if it's below a threshold. ( #783 ) This is disabled by default, but will be enabled by default in a future release. Add support for enabling/disabling an ImageLoader 's internal network observer. ( #741 ) Fix the density of bitmaps decoded by BitmapFactoryDecoder . ( #776 ) Fix Licensee not finding Coil's licence url. ( #774 ) Update androidx.core:core-ktx to 1.6.0. [1.2.2] - June 4, 2021 \u00b6 Fix race condition while converting a drawable with shared state to a bitmap. ( #771 ) Fix ImageLoader.Builder.fallback setting the error drawable instead of the fallback drawable. Fix incorrect data source returned by ResourceUriFetcher . ( #770 ) Fix log check for no available file descriptors on API 26 and 27. Fix incorrect version check for platform vector drawable support. ( #751 ) Update Kotlin (1.5.10). Update Coroutines (1.5.0). Update androidx.appcompat:appcompat-resources to 1.3.0. Update androidx.core:core-ktx to 1.5.0. [1.2.1] - April 27, 2021 \u00b6 Fix VideoFrameUriFetcher attempting to handle http/https URIs. ( #734 [1.2.0] - April 12, 2021 \u00b6 Important : Use an SVG's view bounds to calculate its aspect ratio in SvgDecoder . ( #688 ) Previously, SvgDecoder used an SVG's width / height elements to determine its aspect ratio, however this doesn't correctly follow the SVG specification. To revert to the old behaviour set useViewBoundsAsIntrinsicSize = false when constructing your SvgDecoder . New : Add VideoFrameDecoder to support decoding video frames from any source. ( #689 ) New : Support automatic SVG detection using the source's contents instead of just the MIME type. ( #654 ) New : Support sharing resources using ImageLoader.newBuilder() . ( #653 ) Importantly, this enables sharing memory caches between ImageLoader instances. New : Add support for animated image transformations using AnimatedTransformation . ( #659 ) New : Add support for start/end callbacks for animated drawables. ( #676 ) Fix parsing EXIF data for HEIF/HEIC files. ( #664 ) Fix not using the EmptyBitmapPool implementation if bitmap pooling is disabled. ( #638 ) Without this fix bitmap pooling was still disabled properly, however it used a more heavyweight BitmapPool implementation. Fix case where MovieDrawable.getOpacity would incorrectly return transparent. ( #682 ) Guard against the default temporary directory not existing. ( #683 ) Build using the JVM IR backend. ( #670 ) Update Kotlin (1.4.32). Update Coroutines (1.4.3). Update OkHttp (3.12.13). Update androidx.lifecycle:lifecycle-common-java8 to 2.3.1. [1.1.1] - January 11, 2021 \u00b6 Fix a case where ViewSizeResolver.size could throw an IllegalStateException due to resuming a coroutine more than once. Fix HttpFetcher blocking forever if called from the main thread. Requests that are forced to execute on the main thread using ImageRequest.dispatcher(Dispatchers.Main.immediate) will fail with a NetworkOnMainThreadException unless ImageRequest.networkCachePolicy is set to CachePolicy.DISABLED or CachePolicy.WRITE_ONLY . Rotate video frames from VideoFrameFetcher if the video has rotation metadata. Update Kotlin (1.4.21). Update Coroutines (1.4.2). Update Okio (2.10.0). Update androidx.exifinterface:exifinterface (1.3.2). [1.1.0] - November 24, 2020 \u00b6 Important : Change the CENTER and MATRIX ImageView scale types to resolve to OriginalSize . ( #587 ) This change only affects the implicit size resolution algorithm when the request's size isn't specified explicitly. This change was made to ensure that the visual result of an image request is consistent with ImageView.setImageResource / ImageView.setImageURI . To revert to the old behaviour set a ViewSizeResolver when constructing your request. Important : Return the display size from ViewSizeResolver if the view's layout param is WRAP_CONTENT . ( #562 ) Previously, we would only return the display size if the view has been fully laid out. This change makes the typical behaviour more consistent and intuitive. Add the ability to control alpha pre-multiplication. ( #569 ) Support preferring exact intrinsic size in CrossfadeDrawable . ( #585 ) Check for the full GIF header including version. ( #564 ) Add an empty bitmap pool implementation. ( #561 ) Make EventListener.Factory a functional interface. ( #575 ) Stabilize EventListener . ( #574 ) Add String overload for ImageRequest.Builder.placeholderMemoryCacheKey . Add @JvmOverloads to the ViewSizeResolver constructor. Fix: Mutate start/end drawables in CrossfadeDrawable . ( #572 ) Fix: Fix GIF not playing on second load. ( #577 ) Update Kotlin (1.4.20) and migrate to the kotlin-parcelize plugin. Update Coroutines (1.4.1). [1.0.0] - October 22, 2020 \u00b6 Changes since 0.13.0 : - Add Context.imageLoader extension function. ( #534 ) - Add ImageLoader.executeBlocking extension function. ( #537 ) - Don't shutdown previous singleton image loader if replaced. ( #533 ) Changes since 1.0.0-rc3 : - Fix: Guard against missing/invalid ActivityManager. ( #541 ) - Fix: Allow OkHttp to cache unsuccessful responses. ( #551 ) - Update Kotlin to 1.4.10. - Update Okio to 2.9.0. - Update androidx.exifinterface:exifinterface to 1.3.1. [1.0.0-rc3] - September 21, 2020 \u00b6 Revert using the -Xjvm-default=all compiler flag due to instability. This is a source compatible, but binary incompatible change from previous release candidate versions. Add Context.imageLoader extension function. ( #534 ) Add ImageLoader.executeBlocking extension function. ( #537 ) Don't shutdown previous singleton image loader if replaced. ( #533 ) Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.3.0 [1.0.0-rc2] - September 3, 2020 \u00b6 This release requires Kotlin 1.4.0 or above. All the changes present in 0.13.0 . Depend on the base Kotlin stdlib instead of stdlib-jdk8 . [0.13.0] - September 3, 2020 \u00b6 Important : Launch the Interceptor chain on the main thread by default. ( #513 ) This largely restores the behaviour from 0.11.0 and below where the memory cache would be checked synchronously on the main thread. To revert to using the same behaviour as 0.12.0 where the memory cache is checked on ImageRequest.dispatcher , set ImageLoader.Builder.launchInterceptorChainOnMainThread(false) . See launchInterceptorChainOnMainThread for more information. Fix: Fix potential memory leak if request is started on a ViewTarget in a detached fragment. ( #518 ) Fix: Use ImageRequest.context to load resource URIs. ( #517 ) Fix: Fix race condition that could cause subsequent requests to not be saved to the disk cache. ( #510 ) Fix: Use blockCountLong and blockSizeLong on API 18. Make ImageLoaderFactory a fun interface. Add ImageLoader.Builder.addLastModifiedToFileCacheKey which allows you to enable/disable adding the last modified timestamp to the memory cache key for an image loaded from a File . Update Kotlin to 1.4.0. Update Coroutines to 1.3.9. Update Okio to 2.8.0. [1.0.0-rc1] - August 18, 2020 \u00b6 This release requires Kotlin 1.4.0 or above. Update Kotlin to 1.4.0 and enable -Xjvm-default=all . See here for how to enable -Xjvm-default=all in your build file. This generates Java 8 default methods for default Kotlin interface methods. Remove all existing deprecated methods in 0.12.0. Update Coroutines to 1.3.9. [0.12.0] - August 18, 2020 \u00b6 Breaking : LoadRequest and GetRequest have been replaced with ImageRequest : ImageLoader.execute(LoadRequest) -> ImageLoader.enqueue(ImageRequest) ImageLoader.execute(GetRequest) -> ImageLoader.execute(ImageRequest) ImageRequest implements equals / hashCode . Breaking : A number of classes were renamed and/or changed package: coil.request.RequestResult -> coil.request.ImageResult coil.request.RequestDisposable -> coil.request.Disposable coil.bitmappool.BitmapPool -> coil.bitmap.BitmapPool coil.DefaultRequestOptions -> coil.request.DefaultRequestOptions Breaking : SparseIntArraySet has been removed from the public API. Breaking : TransitionTarget no longer implements ViewTarget . Breaking : ImageRequest.Listener.onSuccess 's signature has changed to return an ImageResult.Metadata instead of just a DataSource . Breaking : Remove support for LoadRequest.aliasKeys . This API is better handled with direct read/write access to the memory cache. Important : Values in the memory cache are no longer resolved synchronously (if called from the main thread). This change was also necessary to support executing Interceptor s on a background dispatcher. This change also moves more work off the main thread, improving performance. Important : Mappers are now executed on a background dispatcher. As a side effect, automatic bitmap sampling is no longer automatically supported. To achieve the same effect, use the MemoryCache.Key of a previous request as the placeholderMemoryCacheKey of the subsequent request. See here for an example . The placeholderMemoryCacheKey API offers more freedom as you can \"link\" two image requests with different data (e.g. different URLs for small/large images). Important : Coil's ImageView extension functions have been moved from the coil.api package to the coil package. Use find + replace to refactor import coil.api.load -> import coil.load . Unfortunately, it's not possible to use Kotlin's ReplaceWith functionality to replace imports. Important : Use standard crossfade if drawables are not the same image. Important : Prefer immutable bitmaps on API 24+. Important : MeasuredMapper has been deprecated in favour of the new Interceptor interface. See here for an example of how to convert a MeasuredMapper into an Interceptor . Interceptor is a much less restrictive API that allows for a wider range of custom logic. Important : ImageRequest.data is now not null. If you create an ImageRequest without setting its data it will return NullRequestData as its data. New : Add support for direct read/write access to an ImageLoader 's MemoryCache . See the docs for more information. New : Add support for Interceptor s. See the docs for more information. Coil's Interceptor design is heavily inspired by OkHttp 's! New : Add the ability to enable/disable bitmap pooling using ImageLoader.Builder.bitmapPoolingEnabled . Bitmap pooling is most effective on API 23 and below, but may still be benificial on API 24 and up (by eagerly calling Bitmap.recycle ). New : Support thread interruption while decoding. Fix parsing multiple segments in content-type header. Rework bitmap reference counting to be more robust. Fix WebP decoding on API < 19 devices. Expose FetchResult and DecodeResult in the EventListener API. Compile with SDK 30. Update Coroutines to 1.3.8. Update OkHttp to 3.12.12. Update Okio to 2.7.0. Update AndroidX dependencies: androidx.appcompat:appcompat-resources -> 1.2.0 androidx.core:core-ktx -> 1.3.1 [0.11.0] - May 14, 2020 \u00b6 Breaking : This version removes all existing deprecated functions. This enables removing Coil's ContentProvider so it doesn't run any code at app startup. Breaking : Convert SparseIntArraySet.size to a val. ( #380 ) Breaking : Move Parameters.count() to an extension function. ( #403 ) Breaking : Make BitmapPool.maxSize an Int. ( #404 ) Important : Make ImageLoader.shutdown() optional (similar to OkHttpClient ). ( #385 ) Fix: Fix AGP 4.1 compatibility. ( #386 ) Fix: Fix measuring GONE views. ( #397 ) Reduce the default memory cache size to 20%. ( #390 ) To restore the existing behaviour set ImageLoaderBuilder.availableMemoryPercentage(0.25) when creating your ImageLoader . Update Coroutines to 1.3.6. Update OkHttp to 3.12.11. [0.10.1] - April 26, 2020 \u00b6 Fix OOM when decoding large PNGs on API 23 and below. ( #372 ). This disables decoding EXIF orientation for PNG files. PNG EXIF orientation is very rarely used and reading PNG EXIF data (even if it's empty) requires buffering the entire file into memory, which is bad for performance. Minor Java compatibility improvements to SparseIntArraySet . Update Okio to 2.6.0. [0.10.0] - April 20, 2020 \u00b6 Highlights \u00b6 This version deprecates most of the DSL API in favour of using the builders directly. Here's what the change looks like: // 0.9.5 (old) val imageLoader = ImageLoader ( context ) { bitmapPoolPercentage ( 0.5 ) crossfade ( true ) } val disposable = imageLoader . load ( context , \"https://www.example.com/image.jpg\" ) { target ( imageView ) } val drawable = imageLoader . get ( \"https://www.example.com/image.jpg\" ) { size ( 512 , 512 ) } // 0.10.0 (new) val imageLoader = ImageLoader . Builder ( context ) . bitmapPoolPercentage ( 0.5 ) . crossfade ( true ) . build () val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . execute ( request ) val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 512 , 512 ) . build () val drawable = imageLoader . execute ( request ). drawable If you're using the io.coil-kt:coil artifact, you can call Coil.execute(request) to execute the request with the singleton ImageLoader . ImageLoader s now have a weak reference memory cache that tracks weak references to images once they're evicted from the strong reference memory cache. This means an image will always be returned from an ImageLoader 's memory cache if there's still a strong reference to it. Generally, this should make the memory cache much more predictable and increase its hit rate. This behaviour can be enabled/disabled with ImageLoaderBuilder.trackWeakReferences . Add a new artifact, io.coil-kt:coil-video , to decode specific frames from a video file. Read more here . Add a new EventListener API for tracking metrics. Add ImageLoaderFactory which can be implemented by your Application to simplify singleton initialization. Full Release Notes \u00b6 Important : Deprecate DSL syntax in favour of builder syntax. ( #267 ) Important : Deprecate Coil and ImageLoader extension functions. ( #322 ) Breaking : Return sealed RequestResult type from ImageLoader.execute(GetRequest) . ( #349 ) Breaking : Rename ExperimentalCoil to ExperimentalCoilApi . Migrate from @Experimental to @RequiresOptIn . ( #306 ) Breaking : Replace CoilLogger with Logger interface. ( #316 ) Breaking : Rename destWidth/destHeight to dstWidth/dstHeight. ( #275 ) Breaking : Re-arrange MovieDrawable 's constructor params. ( #272 ) Breaking : Request.Listener 's methods now receive the full Request object instead of just its data. Breaking : GetRequestBuilder now requires a Context in its constructor. Breaking : Several properties on Request are now nullable. Behaviour change : Include parameter values in the cache key by default. ( #319 ) Behaviour change : Slightly adjust Request.Listener.onStart() timing to be called immediately after Target.onStart() . ( #348 ) New : Add WeakMemoryCache implementation. ( #295 ) New : Add coil-video to support decoding video frames. ( #122 ) New : Introduce EventListener . ( #314 ) New : Introduce ImageLoaderFactory . ( #311 ) New : Support animated HEIF image sequences on Android 11. ( #297 ) New : Improve Java compatibility. ( #262 ) New : Support setting a default CachePolicy . ( #307 ) New : Support setting a default Bitmap.Config . ( #342 ) New : Add ImageLoader.invalidate(key) to clear a single memory cache item ( #55 ) New : Add debug logs to explain why a cached image is not reused. ( #346 ) New : Support error and fallback drawables for get requests. Fix: Fix memory cache miss when Transformation reduces input bitmap's size. ( #357 ) Fix: Ensure radius is below RenderScript max in BlurTransformation. ( #291 ) Fix: Fix decoding high colour depth images. ( #358 ) Fix: Disable ImageDecoderDecoder crash work-around on Android 11 and above. ( #298 ) Fix: Fix failing to read EXIF data on pre-API 23. ( #331 ) Fix: Fix incompatibility with Android R SDK. ( #337 ) Fix: Only enable inexact size if ImageView has a matching SizeResolver . ( #344 ) Fix: Allow cached images to be at most one pixel off requested size. ( #360 ) Fix: Skip crossfade transition if view is not visible. ( #361 ) Deprecate CoilContentProvider . ( #293 ) Annotate several ImageLoader methods with @MainThread . Avoid creating a LifecycleCoroutineDispatcher if the lifecycle is currently started. ( #356 ) Use full package name for OriginalSize.toString() . Preallocate when decoding software bitmap. ( #354 ) Update Kotlin to 1.3.72. Update Coroutines to 1.3.5. Update OkHttp to 3.12.10. Update Okio to 2.5.0. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.2.0 [0.9.5] - February 6, 2020 \u00b6 Fix: Ensure a view is attached before checking if it is hardware accelerated. This fixes a case where requesting a hardware bitmap could miss the memory cache. Update AndroidX dependencies: androidx.core:core-ktx -> 1.2.0 [0.9.4] - February 3, 2020 \u00b6 Fix: Respect aspect ratio when downsampling in ImageDecoderDecoder. Thanks @zhanghai. Previously bitmaps would be returned from the memory cache as long as their config was greater than or equal to the config specified in the request. For example, if you requested an ARGB_8888 bitmap, it would be possible to have a RGBA_F16 bitmap returned to you from the memory cache. Now, the cached config and the requested config must be equal. Make scale and durationMillis public in CrossfadeDrawable and CrossfadeTransition . [0.9.3] - February 1, 2020 \u00b6 Fix: Translate child drawable inside ScaleDrawable to ensure it is centered. Fix: Fix case where GIFs and SVGs would not fill bounds completely. Defer calling HttpUrl.get() to background thread. Improve BitmapFactory null bitmap error message. Add 3 devices to hardware bitmap blacklist. ( #264 ) Update AndroidX dependencies: androidx.lifecycle:lifecycle-common-java8 -> 2.2.0 [0.9.2] - January 19, 2020 \u00b6 Fix: Fix decoding GIFs on pre-API 19. Thanks @mario. Fix: Fix rasterized vector drawables not being marked as sampled. Fix: Throw exception if Movie dimensions are <= 0. Fix: Fix CrossfadeTransition not being resumed for a memory cache event. Fix: Prevent returning hardware bitmaps to all target methods if disallowed. Fix: Fix MovieDrawable not positioning itself in the center of its bounds. Remove automatic scaling from CrossfadeDrawable. Make BitmapPool.trimMemory public. Wrap AnimatedImageDrawable in a ScaleDrawable to ensure it fills its bounds. Add @JvmOverloads to RequestBuilder.setParameter. Set an SVG's view box to its size if the view box is not set. Pass state and level changes to CrossfadeDrawable children. Update OkHttp to 3.12.8. [0.9.1] - December 30, 2019 \u00b6 Fix: Fix crash when calling LoadRequestBuilder.crossfade(false) . [0.9.0] - December 30, 2019 \u00b6 Breaking : Transformation.transform now includes a Size parameter. This is to support transformations that change the size of the output Bitmap based on the size of the Target . Requests with transformations are now also exempt from image sampling . Breaking : Transformation s are now applied to any type of Drawable . Before, Transformation s would be skipped if the input Drawable was not a BitmapDrawable . Now, Drawable s are rendered to a Bitmap before applying the Transformation s. Breaking : Passing null data to ImageLoader.load is now treated as an error and calls Target.onError and Request.Listener.onError with a NullRequestDataException . This change was made to support setting a fallback drawable if data is null . Previously the request was silently ignored. Breaking : RequestDisposable.isDisposed is now a val . New : Support for custom transitions. See here for more info . Transitions are marked as experimental as the API is incubating. New : Add RequestDisposable.await to support suspending while a LoadRequest is in progress. New : Support setting a fallback drawable when request data is null. New : Add Precision . This makes the size of the output Drawable exact while enabling scaling optimizations for targets that support scaling (e.g. ImageViewTarget ). See its documentation for more information. New : Add RequestBuilder.aliasKeys to support matching multiple cache keys. Fix: Make RequestDisposable thread safe. Fix: RoundedCornersTransformation now crops to the size of the target then rounds the corners. Fix: CircleCropTransformation now crops from the center. Fix: Add several devices to the hardware bitmap blacklist . Fix: Preserve aspect ratio when converting a Drawable to a Bitmap. Fix: Fix possible memory cache miss with Scale.FIT . Fix: Ensure Parameters iteration order is deterministic. Fix: Defensive copy when creating Parameters and ComponentRegistry. Fix: Ensure RealBitmapPool's maxSize >= 0. Fix: Show the start drawable if CrossfadeDrawable is not animating or done. Fix: Adjust CrossfadeDrawable to account for children with undefined intrinsic size. Fix: Fix MovieDrawable not scaling properly. Update Kotlin to 1.3.61. Update Kotlin Coroutines to 1.3.3. Update Okio to 2.4.3. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.1.0 [0.8.0] - October 22, 2019 \u00b6 Breaking : SvgDrawable has been removed. Instead, SVGs are now prerendered to BitmapDrawable s by SvgDecoder . This makes SVGs significantly less expensive to render on the main thread . Also SvgDecoder now requires a Context in its constructor. Breaking : SparseIntArraySet extension functions have moved to the coil.extension package. New : Support setting per-request network headers. See here for more info . New : Add new Parameters API to support passing custom data through the image pipeline. New : Support individual corner radii in RoundedCornersTransformation. Thanks @khatv911. New : Add ImageView.clear() to support proactively freeing resources. New : Support loading resources from other packages. New : Add subtractPadding attribute to ViewSizeResolver to enable/disable subtracting a view's padding when measuring. New : Improve HttpUrlFetcher MIME type detection. New : Add Animatable2Compat support to MovieDrawable and CrossfadeDrawable. New : Add RequestBuilder<*>.repeatCount to set the repeat count for a GIF. New : Add BitmapPool creation to the public API. New : Annotate Request.Listener methods with @MainThread . Fix: Make CoilContentProvider visible for testing. Fix: Include night mode in the resource cache key. Fix: Work around ImageDecoder native crash by temporarily writing the source to disk. Fix: Correctly handle contact display photo uris. Fix: Pass tint to CrossfadeDrawable's children. Fix: Fix several instances of not closing sources. Fix: Add a blacklist of devices with broken/incomplete hardware bitmap implementations. Compile against SDK 29. Update Kotlin Coroutines to 1.3.2. Update OkHttp to 3.12.6. Update Okio to 2.4.1. Change appcompat-resources from compileOnly to implementation for coil-base . [0.7.0] - September 8, 2019 \u00b6 Breaking : ImageLoaderBuilder.okHttpClient(OkHttpClient.Builder.() -> Unit) is now ImageLoaderBuilder.okHttpClient(() -> OkHttpClient) . The initializer is also now called lazily on a background thread. If you set a custom OkHttpClient you must set OkHttpClient.cache to enable disk caching. If you don't set a custom OkHttpClient , Coil will create the default OkHttpClient which has disk caching enabled. The default Coil cache can be created using CoilUtils.createDefaultCache(context) . e.g.: val imageLoader = ImageLoader ( context ) { okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } } Breaking : Fetcher.key no longer has a default implementation. Breaking : Previously, only the first applicable Mapper would be called. Now, all applicable Mapper s will be called. No API changes. Breaking : Minor named parameter renaming: url -> uri , factory -> initializer . New : coil-svg artifact, which has an SvgDecoder that supports automatically decoding SVGs. Powered by AndroidSVG . Thanks @rharter. New : load(String) and get(String) now accept any of the supported Uri schemes. e.g. You can now do imageView.load(\"file:///path/to/file.jpg\") . New : Refactor ImageLoader to use Call.Factory instead of OkHttpClient . This allows lazy initialization of the networking resources using ImageLoaderBuilder.okHttpClient { OkHttpClient() } . Thanks @ZacSweers. New : RequestBuilder.decoder to explicitly set the decoder for a request. New : ImageLoaderBuilder.allowHardware to enable/disable hardware bitmaps by default for an ImageLoader. New : Support software rendering in ImageDecoderDecoder. Fix: Multiple bugs with loading vector drawables. Fix: Support WRAP_CONTENT View dimensions. Fix: Support parsing EXIF data longer than 8192 bytes. Fix: Don't stretch drawables with different aspect ratios when crossfading. Fix: Guard against network observer failing to register due to exception. Fix: Fix divide by zero error in MovieDrawable. Thanks @R12rus. Fix: Support nested Android asset files. Thanks @JaCzekanski. Fix: Guard against running out of file descriptors on Android O and O_MR1. Fix: Don't crash when disabling memory cache. Thanks @hansenji. Fix: Ensure Target.cancel is always called from the main thread. Update Kotlin to 1.3.50. Update Kotlin Coroutines to 1.3.0. Update OkHttp to 3.12.4. Update Okio to 2.4.0. Update AndroidX dependencies to the latest stable versions: androidx.appcompat:appcompat -> 1.1.0 androidx.core:core-ktx -> 1.1.0 androidx.lifecycle:lifecycle-common-java8 -> 2.1.0 Replace appcompat with appcompat-resources as an optional compileOnly dependency. appcompat-resources is a much smaller artifact. [0.6.1] - August 16, 2019 \u00b6 New: Add transformations(List<Transformation>) to RequestBuilder. Fix: Add the last modified date to the cache key for file uris. Fix: Ensure View dimensions are evaluated to at least 1px. Fix: Clear MovieDrawable's canvas between frames. Fix: Open assets correctly. [0.6.0] - August 12, 2019 \u00b6 Initial release.","title":"Change Log"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#130-july-10-2021","text":"New : Add support for Jetpack Compose . It's based on Accompanist 's Coil integration, but has a number of changes. Check out the docs for more info. Add allowConversionToBitmap to enable/disable the automatic bitmap conversion for Transformation s. ( #775 ) Add enforceMinimumFrameDelay to ImageDecoderDecoder and GifDecoder to enable rewriting a GIF's frame delay if it's below a threshold. ( #783 ) This is disabled by default, but will be enabled by default in a future release. Add support for enabling/disabling an ImageLoader 's internal network observer. ( #741 ) Fix the density of bitmaps decoded by BitmapFactoryDecoder . ( #776 ) Fix Licensee not finding Coil's licence url. ( #774 ) Update androidx.core:core-ktx to 1.6.0.","title":"[1.3.0] - July 10, 2021"},{"location":"changelog/#122-june-4-2021","text":"Fix race condition while converting a drawable with shared state to a bitmap. ( #771 ) Fix ImageLoader.Builder.fallback setting the error drawable instead of the fallback drawable. Fix incorrect data source returned by ResourceUriFetcher . ( #770 ) Fix log check for no available file descriptors on API 26 and 27. Fix incorrect version check for platform vector drawable support. ( #751 ) Update Kotlin (1.5.10). Update Coroutines (1.5.0). Update androidx.appcompat:appcompat-resources to 1.3.0. Update androidx.core:core-ktx to 1.5.0.","title":"[1.2.2] - June 4, 2021"},{"location":"changelog/#121-april-27-2021","text":"Fix VideoFrameUriFetcher attempting to handle http/https URIs. ( #734","title":"[1.2.1] - April 27, 2021"},{"location":"changelog/#120-april-12-2021","text":"Important : Use an SVG's view bounds to calculate its aspect ratio in SvgDecoder . ( #688 ) Previously, SvgDecoder used an SVG's width / height elements to determine its aspect ratio, however this doesn't correctly follow the SVG specification. To revert to the old behaviour set useViewBoundsAsIntrinsicSize = false when constructing your SvgDecoder . New : Add VideoFrameDecoder to support decoding video frames from any source. ( #689 ) New : Support automatic SVG detection using the source's contents instead of just the MIME type. ( #654 ) New : Support sharing resources using ImageLoader.newBuilder() . ( #653 ) Importantly, this enables sharing memory caches between ImageLoader instances. New : Add support for animated image transformations using AnimatedTransformation . ( #659 ) New : Add support for start/end callbacks for animated drawables. ( #676 ) Fix parsing EXIF data for HEIF/HEIC files. ( #664 ) Fix not using the EmptyBitmapPool implementation if bitmap pooling is disabled. ( #638 ) Without this fix bitmap pooling was still disabled properly, however it used a more heavyweight BitmapPool implementation. Fix case where MovieDrawable.getOpacity would incorrectly return transparent. ( #682 ) Guard against the default temporary directory not existing. ( #683 ) Build using the JVM IR backend. ( #670 ) Update Kotlin (1.4.32). Update Coroutines (1.4.3). Update OkHttp (3.12.13). Update androidx.lifecycle:lifecycle-common-java8 to 2.3.1.","title":"[1.2.0] - April 12, 2021"},{"location":"changelog/#111-january-11-2021","text":"Fix a case where ViewSizeResolver.size could throw an IllegalStateException due to resuming a coroutine more than once. Fix HttpFetcher blocking forever if called from the main thread. Requests that are forced to execute on the main thread using ImageRequest.dispatcher(Dispatchers.Main.immediate) will fail with a NetworkOnMainThreadException unless ImageRequest.networkCachePolicy is set to CachePolicy.DISABLED or CachePolicy.WRITE_ONLY . Rotate video frames from VideoFrameFetcher if the video has rotation metadata. Update Kotlin (1.4.21). Update Coroutines (1.4.2). Update Okio (2.10.0). Update androidx.exifinterface:exifinterface (1.3.2).","title":"[1.1.1] - January 11, 2021"},{"location":"changelog/#110-november-24-2020","text":"Important : Change the CENTER and MATRIX ImageView scale types to resolve to OriginalSize . ( #587 ) This change only affects the implicit size resolution algorithm when the request's size isn't specified explicitly. This change was made to ensure that the visual result of an image request is consistent with ImageView.setImageResource / ImageView.setImageURI . To revert to the old behaviour set a ViewSizeResolver when constructing your request. Important : Return the display size from ViewSizeResolver if the view's layout param is WRAP_CONTENT . ( #562 ) Previously, we would only return the display size if the view has been fully laid out. This change makes the typical behaviour more consistent and intuitive. Add the ability to control alpha pre-multiplication. ( #569 ) Support preferring exact intrinsic size in CrossfadeDrawable . ( #585 ) Check for the full GIF header including version. ( #564 ) Add an empty bitmap pool implementation. ( #561 ) Make EventListener.Factory a functional interface. ( #575 ) Stabilize EventListener . ( #574 ) Add String overload for ImageRequest.Builder.placeholderMemoryCacheKey . Add @JvmOverloads to the ViewSizeResolver constructor. Fix: Mutate start/end drawables in CrossfadeDrawable . ( #572 ) Fix: Fix GIF not playing on second load. ( #577 ) Update Kotlin (1.4.20) and migrate to the kotlin-parcelize plugin. Update Coroutines (1.4.1).","title":"[1.1.0] - November 24, 2020"},{"location":"changelog/#100-october-22-2020","text":"Changes since 0.13.0 : - Add Context.imageLoader extension function. ( #534 ) - Add ImageLoader.executeBlocking extension function. ( #537 ) - Don't shutdown previous singleton image loader if replaced. ( #533 ) Changes since 1.0.0-rc3 : - Fix: Guard against missing/invalid ActivityManager. ( #541 ) - Fix: Allow OkHttp to cache unsuccessful responses. ( #551 ) - Update Kotlin to 1.4.10. - Update Okio to 2.9.0. - Update androidx.exifinterface:exifinterface to 1.3.1.","title":"[1.0.0] - October 22, 2020"},{"location":"changelog/#100-rc3-september-21-2020","text":"Revert using the -Xjvm-default=all compiler flag due to instability. This is a source compatible, but binary incompatible change from previous release candidate versions. Add Context.imageLoader extension function. ( #534 ) Add ImageLoader.executeBlocking extension function. ( #537 ) Don't shutdown previous singleton image loader if replaced. ( #533 ) Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.3.0","title":"[1.0.0-rc3] - September 21, 2020"},{"location":"changelog/#100-rc2-september-3-2020","text":"This release requires Kotlin 1.4.0 or above. All the changes present in 0.13.0 . Depend on the base Kotlin stdlib instead of stdlib-jdk8 .","title":"[1.0.0-rc2] - September 3, 2020"},{"location":"changelog/#0130-september-3-2020","text":"Important : Launch the Interceptor chain on the main thread by default. ( #513 ) This largely restores the behaviour from 0.11.0 and below where the memory cache would be checked synchronously on the main thread. To revert to using the same behaviour as 0.12.0 where the memory cache is checked on ImageRequest.dispatcher , set ImageLoader.Builder.launchInterceptorChainOnMainThread(false) . See launchInterceptorChainOnMainThread for more information. Fix: Fix potential memory leak if request is started on a ViewTarget in a detached fragment. ( #518 ) Fix: Use ImageRequest.context to load resource URIs. ( #517 ) Fix: Fix race condition that could cause subsequent requests to not be saved to the disk cache. ( #510 ) Fix: Use blockCountLong and blockSizeLong on API 18. Make ImageLoaderFactory a fun interface. Add ImageLoader.Builder.addLastModifiedToFileCacheKey which allows you to enable/disable adding the last modified timestamp to the memory cache key for an image loaded from a File . Update Kotlin to 1.4.0. Update Coroutines to 1.3.9. Update Okio to 2.8.0.","title":"[0.13.0] - September 3, 2020"},{"location":"changelog/#100-rc1-august-18-2020","text":"This release requires Kotlin 1.4.0 or above. Update Kotlin to 1.4.0 and enable -Xjvm-default=all . See here for how to enable -Xjvm-default=all in your build file. This generates Java 8 default methods for default Kotlin interface methods. Remove all existing deprecated methods in 0.12.0. Update Coroutines to 1.3.9.","title":"[1.0.0-rc1] - August 18, 2020"},{"location":"changelog/#0120-august-18-2020","text":"Breaking : LoadRequest and GetRequest have been replaced with ImageRequest : ImageLoader.execute(LoadRequest) -> ImageLoader.enqueue(ImageRequest) ImageLoader.execute(GetRequest) -> ImageLoader.execute(ImageRequest) ImageRequest implements equals / hashCode . Breaking : A number of classes were renamed and/or changed package: coil.request.RequestResult -> coil.request.ImageResult coil.request.RequestDisposable -> coil.request.Disposable coil.bitmappool.BitmapPool -> coil.bitmap.BitmapPool coil.DefaultRequestOptions -> coil.request.DefaultRequestOptions Breaking : SparseIntArraySet has been removed from the public API. Breaking : TransitionTarget no longer implements ViewTarget . Breaking : ImageRequest.Listener.onSuccess 's signature has changed to return an ImageResult.Metadata instead of just a DataSource . Breaking : Remove support for LoadRequest.aliasKeys . This API is better handled with direct read/write access to the memory cache. Important : Values in the memory cache are no longer resolved synchronously (if called from the main thread). This change was also necessary to support executing Interceptor s on a background dispatcher. This change also moves more work off the main thread, improving performance. Important : Mappers are now executed on a background dispatcher. As a side effect, automatic bitmap sampling is no longer automatically supported. To achieve the same effect, use the MemoryCache.Key of a previous request as the placeholderMemoryCacheKey of the subsequent request. See here for an example . The placeholderMemoryCacheKey API offers more freedom as you can \"link\" two image requests with different data (e.g. different URLs for small/large images). Important : Coil's ImageView extension functions have been moved from the coil.api package to the coil package. Use find + replace to refactor import coil.api.load -> import coil.load . Unfortunately, it's not possible to use Kotlin's ReplaceWith functionality to replace imports. Important : Use standard crossfade if drawables are not the same image. Important : Prefer immutable bitmaps on API 24+. Important : MeasuredMapper has been deprecated in favour of the new Interceptor interface. See here for an example of how to convert a MeasuredMapper into an Interceptor . Interceptor is a much less restrictive API that allows for a wider range of custom logic. Important : ImageRequest.data is now not null. If you create an ImageRequest without setting its data it will return NullRequestData as its data. New : Add support for direct read/write access to an ImageLoader 's MemoryCache . See the docs for more information. New : Add support for Interceptor s. See the docs for more information. Coil's Interceptor design is heavily inspired by OkHttp 's! New : Add the ability to enable/disable bitmap pooling using ImageLoader.Builder.bitmapPoolingEnabled . Bitmap pooling is most effective on API 23 and below, but may still be benificial on API 24 and up (by eagerly calling Bitmap.recycle ). New : Support thread interruption while decoding. Fix parsing multiple segments in content-type header. Rework bitmap reference counting to be more robust. Fix WebP decoding on API < 19 devices. Expose FetchResult and DecodeResult in the EventListener API. Compile with SDK 30. Update Coroutines to 1.3.8. Update OkHttp to 3.12.12. Update Okio to 2.7.0. Update AndroidX dependencies: androidx.appcompat:appcompat-resources -> 1.2.0 androidx.core:core-ktx -> 1.3.1","title":"[0.12.0] - August 18, 2020"},{"location":"changelog/#0110-may-14-2020","text":"Breaking : This version removes all existing deprecated functions. This enables removing Coil's ContentProvider so it doesn't run any code at app startup. Breaking : Convert SparseIntArraySet.size to a val. ( #380 ) Breaking : Move Parameters.count() to an extension function. ( #403 ) Breaking : Make BitmapPool.maxSize an Int. ( #404 ) Important : Make ImageLoader.shutdown() optional (similar to OkHttpClient ). ( #385 ) Fix: Fix AGP 4.1 compatibility. ( #386 ) Fix: Fix measuring GONE views. ( #397 ) Reduce the default memory cache size to 20%. ( #390 ) To restore the existing behaviour set ImageLoaderBuilder.availableMemoryPercentage(0.25) when creating your ImageLoader . Update Coroutines to 1.3.6. Update OkHttp to 3.12.11.","title":"[0.11.0] - May 14, 2020"},{"location":"changelog/#0101-april-26-2020","text":"Fix OOM when decoding large PNGs on API 23 and below. ( #372 ). This disables decoding EXIF orientation for PNG files. PNG EXIF orientation is very rarely used and reading PNG EXIF data (even if it's empty) requires buffering the entire file into memory, which is bad for performance. Minor Java compatibility improvements to SparseIntArraySet . Update Okio to 2.6.0.","title":"[0.10.1] - April 26, 2020"},{"location":"changelog/#0100-april-20-2020","text":"","title":"[0.10.0] - April 20, 2020"},{"location":"changelog/#highlights","text":"This version deprecates most of the DSL API in favour of using the builders directly. Here's what the change looks like: // 0.9.5 (old) val imageLoader = ImageLoader ( context ) { bitmapPoolPercentage ( 0.5 ) crossfade ( true ) } val disposable = imageLoader . load ( context , \"https://www.example.com/image.jpg\" ) { target ( imageView ) } val drawable = imageLoader . get ( \"https://www.example.com/image.jpg\" ) { size ( 512 , 512 ) } // 0.10.0 (new) val imageLoader = ImageLoader . Builder ( context ) . bitmapPoolPercentage ( 0.5 ) . crossfade ( true ) . build () val request = LoadRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . execute ( request ) val request = GetRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 512 , 512 ) . build () val drawable = imageLoader . execute ( request ). drawable If you're using the io.coil-kt:coil artifact, you can call Coil.execute(request) to execute the request with the singleton ImageLoader . ImageLoader s now have a weak reference memory cache that tracks weak references to images once they're evicted from the strong reference memory cache. This means an image will always be returned from an ImageLoader 's memory cache if there's still a strong reference to it. Generally, this should make the memory cache much more predictable and increase its hit rate. This behaviour can be enabled/disabled with ImageLoaderBuilder.trackWeakReferences . Add a new artifact, io.coil-kt:coil-video , to decode specific frames from a video file. Read more here . Add a new EventListener API for tracking metrics. Add ImageLoaderFactory which can be implemented by your Application to simplify singleton initialization.","title":"Highlights"},{"location":"changelog/#full-release-notes","text":"Important : Deprecate DSL syntax in favour of builder syntax. ( #267 ) Important : Deprecate Coil and ImageLoader extension functions. ( #322 ) Breaking : Return sealed RequestResult type from ImageLoader.execute(GetRequest) . ( #349 ) Breaking : Rename ExperimentalCoil to ExperimentalCoilApi . Migrate from @Experimental to @RequiresOptIn . ( #306 ) Breaking : Replace CoilLogger with Logger interface. ( #316 ) Breaking : Rename destWidth/destHeight to dstWidth/dstHeight. ( #275 ) Breaking : Re-arrange MovieDrawable 's constructor params. ( #272 ) Breaking : Request.Listener 's methods now receive the full Request object instead of just its data. Breaking : GetRequestBuilder now requires a Context in its constructor. Breaking : Several properties on Request are now nullable. Behaviour change : Include parameter values in the cache key by default. ( #319 ) Behaviour change : Slightly adjust Request.Listener.onStart() timing to be called immediately after Target.onStart() . ( #348 ) New : Add WeakMemoryCache implementation. ( #295 ) New : Add coil-video to support decoding video frames. ( #122 ) New : Introduce EventListener . ( #314 ) New : Introduce ImageLoaderFactory . ( #311 ) New : Support animated HEIF image sequences on Android 11. ( #297 ) New : Improve Java compatibility. ( #262 ) New : Support setting a default CachePolicy . ( #307 ) New : Support setting a default Bitmap.Config . ( #342 ) New : Add ImageLoader.invalidate(key) to clear a single memory cache item ( #55 ) New : Add debug logs to explain why a cached image is not reused. ( #346 ) New : Support error and fallback drawables for get requests. Fix: Fix memory cache miss when Transformation reduces input bitmap's size. ( #357 ) Fix: Ensure radius is below RenderScript max in BlurTransformation. ( #291 ) Fix: Fix decoding high colour depth images. ( #358 ) Fix: Disable ImageDecoderDecoder crash work-around on Android 11 and above. ( #298 ) Fix: Fix failing to read EXIF data on pre-API 23. ( #331 ) Fix: Fix incompatibility with Android R SDK. ( #337 ) Fix: Only enable inexact size if ImageView has a matching SizeResolver . ( #344 ) Fix: Allow cached images to be at most one pixel off requested size. ( #360 ) Fix: Skip crossfade transition if view is not visible. ( #361 ) Deprecate CoilContentProvider . ( #293 ) Annotate several ImageLoader methods with @MainThread . Avoid creating a LifecycleCoroutineDispatcher if the lifecycle is currently started. ( #356 ) Use full package name for OriginalSize.toString() . Preallocate when decoding software bitmap. ( #354 ) Update Kotlin to 1.3.72. Update Coroutines to 1.3.5. Update OkHttp to 3.12.10. Update Okio to 2.5.0. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.2.0","title":"Full Release Notes"},{"location":"changelog/#095-february-6-2020","text":"Fix: Ensure a view is attached before checking if it is hardware accelerated. This fixes a case where requesting a hardware bitmap could miss the memory cache. Update AndroidX dependencies: androidx.core:core-ktx -> 1.2.0","title":"[0.9.5] - February 6, 2020"},{"location":"changelog/#094-february-3-2020","text":"Fix: Respect aspect ratio when downsampling in ImageDecoderDecoder. Thanks @zhanghai. Previously bitmaps would be returned from the memory cache as long as their config was greater than or equal to the config specified in the request. For example, if you requested an ARGB_8888 bitmap, it would be possible to have a RGBA_F16 bitmap returned to you from the memory cache. Now, the cached config and the requested config must be equal. Make scale and durationMillis public in CrossfadeDrawable and CrossfadeTransition .","title":"[0.9.4] - February 3, 2020"},{"location":"changelog/#093-february-1-2020","text":"Fix: Translate child drawable inside ScaleDrawable to ensure it is centered. Fix: Fix case where GIFs and SVGs would not fill bounds completely. Defer calling HttpUrl.get() to background thread. Improve BitmapFactory null bitmap error message. Add 3 devices to hardware bitmap blacklist. ( #264 ) Update AndroidX dependencies: androidx.lifecycle:lifecycle-common-java8 -> 2.2.0","title":"[0.9.3] - February 1, 2020"},{"location":"changelog/#092-january-19-2020","text":"Fix: Fix decoding GIFs on pre-API 19. Thanks @mario. Fix: Fix rasterized vector drawables not being marked as sampled. Fix: Throw exception if Movie dimensions are <= 0. Fix: Fix CrossfadeTransition not being resumed for a memory cache event. Fix: Prevent returning hardware bitmaps to all target methods if disallowed. Fix: Fix MovieDrawable not positioning itself in the center of its bounds. Remove automatic scaling from CrossfadeDrawable. Make BitmapPool.trimMemory public. Wrap AnimatedImageDrawable in a ScaleDrawable to ensure it fills its bounds. Add @JvmOverloads to RequestBuilder.setParameter. Set an SVG's view box to its size if the view box is not set. Pass state and level changes to CrossfadeDrawable children. Update OkHttp to 3.12.8.","title":"[0.9.2] - January 19, 2020"},{"location":"changelog/#091-december-30-2019","text":"Fix: Fix crash when calling LoadRequestBuilder.crossfade(false) .","title":"[0.9.1] - December 30, 2019"},{"location":"changelog/#090-december-30-2019","text":"Breaking : Transformation.transform now includes a Size parameter. This is to support transformations that change the size of the output Bitmap based on the size of the Target . Requests with transformations are now also exempt from image sampling . Breaking : Transformation s are now applied to any type of Drawable . Before, Transformation s would be skipped if the input Drawable was not a BitmapDrawable . Now, Drawable s are rendered to a Bitmap before applying the Transformation s. Breaking : Passing null data to ImageLoader.load is now treated as an error and calls Target.onError and Request.Listener.onError with a NullRequestDataException . This change was made to support setting a fallback drawable if data is null . Previously the request was silently ignored. Breaking : RequestDisposable.isDisposed is now a val . New : Support for custom transitions. See here for more info . Transitions are marked as experimental as the API is incubating. New : Add RequestDisposable.await to support suspending while a LoadRequest is in progress. New : Support setting a fallback drawable when request data is null. New : Add Precision . This makes the size of the output Drawable exact while enabling scaling optimizations for targets that support scaling (e.g. ImageViewTarget ). See its documentation for more information. New : Add RequestBuilder.aliasKeys to support matching multiple cache keys. Fix: Make RequestDisposable thread safe. Fix: RoundedCornersTransformation now crops to the size of the target then rounds the corners. Fix: CircleCropTransformation now crops from the center. Fix: Add several devices to the hardware bitmap blacklist . Fix: Preserve aspect ratio when converting a Drawable to a Bitmap. Fix: Fix possible memory cache miss with Scale.FIT . Fix: Ensure Parameters iteration order is deterministic. Fix: Defensive copy when creating Parameters and ComponentRegistry. Fix: Ensure RealBitmapPool's maxSize >= 0. Fix: Show the start drawable if CrossfadeDrawable is not animating or done. Fix: Adjust CrossfadeDrawable to account for children with undefined intrinsic size. Fix: Fix MovieDrawable not scaling properly. Update Kotlin to 1.3.61. Update Kotlin Coroutines to 1.3.3. Update Okio to 2.4.3. Update AndroidX dependencies: androidx.exifinterface:exifinterface -> 1.1.0","title":"[0.9.0] - December 30, 2019"},{"location":"changelog/#080-october-22-2019","text":"Breaking : SvgDrawable has been removed. Instead, SVGs are now prerendered to BitmapDrawable s by SvgDecoder . This makes SVGs significantly less expensive to render on the main thread . Also SvgDecoder now requires a Context in its constructor. Breaking : SparseIntArraySet extension functions have moved to the coil.extension package. New : Support setting per-request network headers. See here for more info . New : Add new Parameters API to support passing custom data through the image pipeline. New : Support individual corner radii in RoundedCornersTransformation. Thanks @khatv911. New : Add ImageView.clear() to support proactively freeing resources. New : Support loading resources from other packages. New : Add subtractPadding attribute to ViewSizeResolver to enable/disable subtracting a view's padding when measuring. New : Improve HttpUrlFetcher MIME type detection. New : Add Animatable2Compat support to MovieDrawable and CrossfadeDrawable. New : Add RequestBuilder<*>.repeatCount to set the repeat count for a GIF. New : Add BitmapPool creation to the public API. New : Annotate Request.Listener methods with @MainThread . Fix: Make CoilContentProvider visible for testing. Fix: Include night mode in the resource cache key. Fix: Work around ImageDecoder native crash by temporarily writing the source to disk. Fix: Correctly handle contact display photo uris. Fix: Pass tint to CrossfadeDrawable's children. Fix: Fix several instances of not closing sources. Fix: Add a blacklist of devices with broken/incomplete hardware bitmap implementations. Compile against SDK 29. Update Kotlin Coroutines to 1.3.2. Update OkHttp to 3.12.6. Update Okio to 2.4.1. Change appcompat-resources from compileOnly to implementation for coil-base .","title":"[0.8.0] - October 22, 2019"},{"location":"changelog/#070-september-8-2019","text":"Breaking : ImageLoaderBuilder.okHttpClient(OkHttpClient.Builder.() -> Unit) is now ImageLoaderBuilder.okHttpClient(() -> OkHttpClient) . The initializer is also now called lazily on a background thread. If you set a custom OkHttpClient you must set OkHttpClient.cache to enable disk caching. If you don't set a custom OkHttpClient , Coil will create the default OkHttpClient which has disk caching enabled. The default Coil cache can be created using CoilUtils.createDefaultCache(context) . e.g.: val imageLoader = ImageLoader ( context ) { okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } } Breaking : Fetcher.key no longer has a default implementation. Breaking : Previously, only the first applicable Mapper would be called. Now, all applicable Mapper s will be called. No API changes. Breaking : Minor named parameter renaming: url -> uri , factory -> initializer . New : coil-svg artifact, which has an SvgDecoder that supports automatically decoding SVGs. Powered by AndroidSVG . Thanks @rharter. New : load(String) and get(String) now accept any of the supported Uri schemes. e.g. You can now do imageView.load(\"file:///path/to/file.jpg\") . New : Refactor ImageLoader to use Call.Factory instead of OkHttpClient . This allows lazy initialization of the networking resources using ImageLoaderBuilder.okHttpClient { OkHttpClient() } . Thanks @ZacSweers. New : RequestBuilder.decoder to explicitly set the decoder for a request. New : ImageLoaderBuilder.allowHardware to enable/disable hardware bitmaps by default for an ImageLoader. New : Support software rendering in ImageDecoderDecoder. Fix: Multiple bugs with loading vector drawables. Fix: Support WRAP_CONTENT View dimensions. Fix: Support parsing EXIF data longer than 8192 bytes. Fix: Don't stretch drawables with different aspect ratios when crossfading. Fix: Guard against network observer failing to register due to exception. Fix: Fix divide by zero error in MovieDrawable. Thanks @R12rus. Fix: Support nested Android asset files. Thanks @JaCzekanski. Fix: Guard against running out of file descriptors on Android O and O_MR1. Fix: Don't crash when disabling memory cache. Thanks @hansenji. Fix: Ensure Target.cancel is always called from the main thread. Update Kotlin to 1.3.50. Update Kotlin Coroutines to 1.3.0. Update OkHttp to 3.12.4. Update Okio to 2.4.0. Update AndroidX dependencies to the latest stable versions: androidx.appcompat:appcompat -> 1.1.0 androidx.core:core-ktx -> 1.1.0 androidx.lifecycle:lifecycle-common-java8 -> 2.1.0 Replace appcompat with appcompat-resources as an optional compileOnly dependency. appcompat-resources is a much smaller artifact.","title":"[0.7.0] - September 8, 2019"},{"location":"changelog/#061-august-16-2019","text":"New: Add transformations(List<Transformation>) to RequestBuilder. Fix: Add the last modified date to the cache key for file uris. Fix: Ensure View dimensions are evaluated to at least 1px. Fix: Clear MovieDrawable's canvas between frames. Fix: Open assets correctly.","title":"[0.6.1] - August 16, 2019"},{"location":"changelog/#060-august-12-2019","text":"Initial release.","title":"[0.6.0] - August 12, 2019"},{"location":"code_of_conduct/","text":"Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"compose/","text":"Jetpack Compose \u00b6 To add support for Jetpack Compose , import the extension library: implementation ( \"io.coil-kt:coil-compose:1.3.0\" ) Then use the rememberImagePainter function to create an ImagePainter that can be drawn by the Image composable: // Basic Image ( painter = rememberImagePainter ( \"https://www.example.com/image.jpg\" ), contentDescription = null , modifier = Modifier . size ( 128. dp ) ) // Advanced Image ( painter = rememberImagePainter ( data = \"https://www.example.com/image.jpg\" , builder = { transformation ( CircleCropTransformation ()) allowHardware ( false ) } ), contentDescription = null , modifier = Modifier . size ( 128. dp ) ) ImagePainter manages the asynchronous image request and handles drawing the placeholder/success/error drawables. Transitions \u00b6 You can enable the built in crossfade transition using ImageRequest.Builder.crossfade : Image ( painter = rememberImagePainter ( data = \"https://www.example.com/image.jpg\" , builder = { crossfade ( true ) } ), contentDescription = null , modifier = Modifier . size ( 128. dp ) ) Custom Transition s do not work with rememberImagePainter as they require a View reference. CrossfadeTransition works due to special internal support. That said, it's possible to create custom transitions in Compose by observing the ImagePainter 's state: val painter = rememberImagePainter ( \"https://www.example.com/image.jpg\" ) val state = painter . state if ( state is ImagePainter . State . Success && state . metadata . dataSource != DataSource . MEMORY_CACHE }) { // Perform the transition animation. } Image ( painter = painter , contentDescription = null , modifier = Modifier . size ( 128. dp ) ) In the above example, the the composable will recompose when the ImagePainter 's state changes. If the image request is successful and not served from the memory cache, it'll execute the animation inside the if statement. LocalImageLoader \u00b6 The integration also adds a pseudo- CompositionLocal for getting the local ImageLoader . In most cases the local ImageLoader will be the singleton ImageLoader , however it's possible to overwrite the local ImageLoader using a CompositionLocalProvider if necessary. // Get val imageLoader = LocalImageLoader . current // Set CompositionLocalProvider ( LocalImageLoader provides ImageLoader ( context )) { // Describe the rest of the UI. } Note There's also the coil-compose-base artifact which is a subset of coil-compose . It does not include LocalImageLoader and the singleton ImageLoader .","title":"Jetpack Compose"},{"location":"compose/#jetpack-compose","text":"To add support for Jetpack Compose , import the extension library: implementation ( \"io.coil-kt:coil-compose:1.3.0\" ) Then use the rememberImagePainter function to create an ImagePainter that can be drawn by the Image composable: // Basic Image ( painter = rememberImagePainter ( \"https://www.example.com/image.jpg\" ), contentDescription = null , modifier = Modifier . size ( 128. dp ) ) // Advanced Image ( painter = rememberImagePainter ( data = \"https://www.example.com/image.jpg\" , builder = { transformation ( CircleCropTransformation ()) allowHardware ( false ) } ), contentDescription = null , modifier = Modifier . size ( 128. dp ) ) ImagePainter manages the asynchronous image request and handles drawing the placeholder/success/error drawables.","title":"Jetpack Compose"},{"location":"compose/#transitions","text":"You can enable the built in crossfade transition using ImageRequest.Builder.crossfade : Image ( painter = rememberImagePainter ( data = \"https://www.example.com/image.jpg\" , builder = { crossfade ( true ) } ), contentDescription = null , modifier = Modifier . size ( 128. dp ) ) Custom Transition s do not work with rememberImagePainter as they require a View reference. CrossfadeTransition works due to special internal support. That said, it's possible to create custom transitions in Compose by observing the ImagePainter 's state: val painter = rememberImagePainter ( \"https://www.example.com/image.jpg\" ) val state = painter . state if ( state is ImagePainter . State . Success && state . metadata . dataSource != DataSource . MEMORY_CACHE }) { // Perform the transition animation. } Image ( painter = painter , contentDescription = null , modifier = Modifier . size ( 128. dp ) ) In the above example, the the composable will recompose when the ImagePainter 's state changes. If the image request is successful and not served from the memory cache, it'll execute the animation inside the if statement.","title":"Transitions"},{"location":"compose/#localimageloader","text":"The integration also adds a pseudo- CompositionLocal for getting the local ImageLoader . In most cases the local ImageLoader will be the singleton ImageLoader , however it's possible to overwrite the local ImageLoader using a CompositionLocalProvider if necessary. // Get val imageLoader = LocalImageLoader . current // Set CompositionLocalProvider ( LocalImageLoader provides ImageLoader ( context )) { // Describe the rest of the UI. } Note There's also the coil-compose-base artifact which is a subset of coil-compose . It does not include LocalImageLoader and the singleton ImageLoader .","title":"LocalImageLoader"},{"location":"contributing/","text":"Contributing \u00b6 In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. Issues that are tagged as help wanted are great issues to get started contributing to Coil. If you have a new feature idea, please create an enhancement request so it can be discussed or build it in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . If you are making an API change, run ./gradlew apiDump and include any changed files in your pull request. Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"contributing/#contributing","text":"In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements. Issues that are tagged as help wanted are great issues to get started contributing to Coil. If you have a new feature idea, please create an enhancement request so it can be discussed or build it in an external library. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running ./test.sh . If you are making an API change, run ./gradlew apiDump and include any changed files in your pull request. Modified from OkHttp's Contributing section.","title":"Contributing"},{"location":"faq/","text":"FAQ \u00b6 Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search our Github issues . Can Coil be used with Java projects or mixed Kotlin/Java projects? \u00b6 Yes! Read here . How do I preload an image? \u00b6 Read here . How do I set up disk caching? \u00b6 Read here . How do I enable logging? \u00b6 Set logger(DebugLogger()) when constructing your ImageLoader . Note DebugLogger should only be used in debug builds. How do I get development snapshots? \u00b6 Add the snapshots repository to your list of repositories: Gradle ( .gradle ): allprojects { repositories { maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' } } } Gradle Kotlin DSL ( .gradle.kts ): allprojects { repositories { maven ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Then depend on the same artifacts with the latest snapshot version . Note Snapshots are deployed for each new commit on main that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.","title":"FAQ"},{"location":"faq/#faq","text":"Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search our Github issues .","title":"FAQ"},{"location":"faq/#can-coil-be-used-with-java-projects-or-mixed-kotlinjava-projects","text":"Yes! Read here .","title":"Can Coil be used with Java projects or mixed Kotlin/Java projects?"},{"location":"faq/#how-do-i-preload-an-image","text":"Read here .","title":"How do I preload an image?"},{"location":"faq/#how-do-i-set-up-disk-caching","text":"Read here .","title":"How do I set up disk caching?"},{"location":"faq/#how-do-i-enable-logging","text":"Set logger(DebugLogger()) when constructing your ImageLoader . Note DebugLogger should only be used in debug builds.","title":"How do I enable logging?"},{"location":"faq/#how-do-i-get-development-snapshots","text":"Add the snapshots repository to your list of repositories: Gradle ( .gradle ): allprojects { repositories { maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' } } } Gradle Kotlin DSL ( .gradle.kts ): allprojects { repositories { maven ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Then depend on the same artifacts with the latest snapshot version . Note Snapshots are deployed for each new commit on main that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.","title":"How do I get development snapshots?"},{"location":"getting_started/","text":"Getting Started \u00b6 Artifacts \u00b6 Coil has 7 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact which depends on io.coil-kt:coil-base and includes the Coil singleton and the ImageView extension functions. io.coil-kt:coil-base : A subset of io.coil-kt:coil which does not include the singleton ImageLoader and the ImageView extension functions. io.coil-kt:coil-compose : Includes support for Jetpack Compose . io.coil-kt:coil-compose-base : A subset of io.coil-kt:coil-compose which does not include functions that depend on the singleton ImageLoader . io.coil-kt:coil-gif : Includes two decoders to support decoding GIFs. See GIFs for more details. io.coil-kt:coil-svg : Includes a decoder to support decoding SVGs. See SVGs for more details. io.coil-kt:coil-video : Includes two fetchers to support fetching and decoding frames from any of Android's supported video formats . See videos for more details. You should depend on io.coil-kt:coil-base and not io.coil-kt:coil if either of the following is true: You are writing a library that depends on Coil. This is to avoid opting your users into the singleton. You want to use dependency injection to inject your ImageLoader instance(s). If you need transformations that aren't part of the base Coil artifact, check out the third-party coil-transformations library hosted here . Java 8 \u00b6 Coil requires Java 8 bytecode . To enable this feature add the following to your Gradle build script: Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } } Image Loaders \u00b6 ImageLoader s are service classes that execute ImageRequest s. ImageLoader s handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . availableMemoryPercentage ( 0.25 ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, bitmap pool, and network observer. It's recommended, though not required, to call shutdown when you've finished using an image loader. Calling shutdown preemptively frees its memory and cleans up any observers. If you only create and use a single ImageLoader , you do not need to shut it down as it will be freed when your app is killed. Image Requests \u00b6 ImageRequest s are value classes that are executed by ImageLoader s. They describe where an image should be loaded from, how it should be loaded, and any extra parameters. An ImageLoader has two methods that can execute a request: enqueue : Enqueues the ImageRequest to be executed asynchronously on a background thread. execute : Executes the ImageRequest in the current coroutine and returns an ImageResult . All requests should set data (i.e. url, uri, file, drawable resource, etc.). This is what the ImageLoader will use to decide where to fetch the image data from. If you do not set data , it will default to NullRequestData . Additionally, you likely want to set a target when enqueuing a request. It's optional, but the target is what will receive the loaded placeholder/success/error drawables. Executed requests return an ImageResult which has the success/error drawable. Here's an example: // enqueue val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . enqueue ( request ) // execute val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request ) Singleton \u00b6 If you are using the io.coil-kt:coil artifact, you can set the singleton ImageLoader instance by either: Implementing ImageLoaderFactory on your Application class (prefer this method): class MyApplication : Application (), ImageLoaderFactory { override fun newImageLoader (): ImageLoader { return ImageLoader . Builder ( applicationContext ) . crossfade ( true ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( applicationContext )) . build () } . build () } } Or calling Coil.setImageLoader : val imageLoader = ImageLoader . Builder ( context ) . crossfade ( true ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Coil . setImageLoader ( imageLoader ) The singleton ImageLoader can be retrieved using the Context.imageLoader extension function: val imageLoader = context . imageLoader Setting the singleton ImageLoader is optional. If you don't set one, Coil will lazily create an ImageLoader with the default values. If you're using the io.coil-kt:coil-base artifact, you should create your own ImageLoader instance(s) and inject them throughout your app with dependency injection. Read more about dependency injection here . Note If you set a custom OkHttpClient , you must set a cache implementation or the ImageLoader will have no disk cache. A default Coil cache instance can be created using CoilUtils.createDefaultCache . ImageView Extension Functions \u00b6 The io.coil-kt:coil artifact provides a set of type-safe ImageView extension functions. Here's an example for loading a URL into an ImageView : imageView . load ( \"https://www.example.com/image.jpg\" ) The above call is equivalent to: val imageLoader = imageView . context . imageLoader val request = ImageRequest . Builder ( imageView . context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () imageLoader . enqueue ( request ) ImageView.load calls can be configured with an optional trailing lambda parameter: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here for more information. Supported Data Types \u00b6 The base data types that are supported by all ImageLoader instances are: String (mapped to a Uri) HttpUrl Uri ( android.resource , content , file , http , and https schemes only) File @DrawableRes Int Drawable Bitmap Supported Image Formats \u00b6 All ImageLoader s support the following non-animated file types: BMP JPEG PNG WebP HEIF (Android 8.0+) Additionally, Coil has extension libraries for the following file types: coil-gif : GIF, animated WebP (Android 9.0+), animated HEIF (Android 11.0+) coil-svg : SVG coil-video : Static video frames from any video codec supported by Android Preloading \u00b6 To preload an image into memory, enqueue or execute an ImageRequest without a Target : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) // Optional, but setting a ViewSizeResolver will conserve memory by limiting the size the image should be preloaded into memory at. . size ( ViewSizeResolver ( imageView )) . build () imageLoader . enqueue ( request ) To preload a network image only into the disk cache, disable the memory cache for the request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . memoryCachePolicy ( CachePolicy . DISABLED ) . build () imageLoader . enqueue ( request ) Cancelling Requests \u00b6 ImageRequest s will be automatically cancelled in the following cases: request.lifecycle reaches the DESTROYED state. request.target is a ViewTarget and its View is detached. Additionally, ImageLoader.enqueue returns a Disposable , which can be used to dispose the request (which cancels it and frees its associated resources): val disposable = imageView . load ( \"https://www.example.com/image.jpg\" ) // Cancel the request. disposable . dispose () Memory Cache \u00b6 Each ImageLoader has its own MemoryCache of recently loaded images. To read/write a Bitmap to the memory cache, you need a MemoryCache.Key . There are two ways to get a MemoryCache.Key : Create a MemoryCache.Key using its String constructor: MemoryCache.Key(\"my_cache_key\") Get the MemoryCache.Key from an executed request: // If using the ImageLoader singleton val memoryCacheKey = imageView . metadata . memoryCacheKey // Enqueue val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . listener { _ , metadata -> val memoryCacheKey = metadata . memoryCacheKey } . build () imageLoader . enqueue ( request ) // Execute val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request ) as SuccessResult val memoryCacheKey = result . metadata . memoryCacheKey Once you have the memory cache key, you can read/write to the memory cache synchronously: // Get val bitmap : Bitmap? = imageLoader . memoryCache [ memoryCacheKey ] // Set imageLoader . memoryCache [ memoryCacheKey ] = bitmap","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#artifacts","text":"Coil has 7 artifacts published to mavenCentral() : io.coil-kt:coil : The default artifact which depends on io.coil-kt:coil-base and includes the Coil singleton and the ImageView extension functions. io.coil-kt:coil-base : A subset of io.coil-kt:coil which does not include the singleton ImageLoader and the ImageView extension functions. io.coil-kt:coil-compose : Includes support for Jetpack Compose . io.coil-kt:coil-compose-base : A subset of io.coil-kt:coil-compose which does not include functions that depend on the singleton ImageLoader . io.coil-kt:coil-gif : Includes two decoders to support decoding GIFs. See GIFs for more details. io.coil-kt:coil-svg : Includes a decoder to support decoding SVGs. See SVGs for more details. io.coil-kt:coil-video : Includes two fetchers to support fetching and decoding frames from any of Android's supported video formats . See videos for more details. You should depend on io.coil-kt:coil-base and not io.coil-kt:coil if either of the following is true: You are writing a library that depends on Coil. This is to avoid opting your users into the singleton. You want to use dependency injection to inject your ImageLoader instance(s). If you need transformations that aren't part of the base Coil artifact, check out the third-party coil-transformations library hosted here .","title":"Artifacts"},{"location":"getting_started/#java-8","text":"Coil requires Java 8 bytecode . To enable this feature add the following to your Gradle build script: Gradle ( .gradle ): android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } } Gradle Kotlin DSL ( .gradle.kts ): android { compileOptions { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } kotlinOptions { jvmTarget = \"1.8\" } }","title":"Java 8"},{"location":"getting_started/#image-loaders","text":"ImageLoader s are service classes that execute ImageRequest s. ImageLoader s handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . availableMemoryPercentage ( 0.25 ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, bitmap pool, and network observer. It's recommended, though not required, to call shutdown when you've finished using an image loader. Calling shutdown preemptively frees its memory and cleans up any observers. If you only create and use a single ImageLoader , you do not need to shut it down as it will be freed when your app is killed.","title":"Image Loaders"},{"location":"getting_started/#image-requests","text":"ImageRequest s are value classes that are executed by ImageLoader s. They describe where an image should be loaded from, how it should be loaded, and any extra parameters. An ImageLoader has two methods that can execute a request: enqueue : Enqueues the ImageRequest to be executed asynchronously on a background thread. execute : Executes the ImageRequest in the current coroutine and returns an ImageResult . All requests should set data (i.e. url, uri, file, drawable resource, etc.). This is what the ImageLoader will use to decide where to fetch the image data from. If you do not set data , it will default to NullRequestData . Additionally, you likely want to set a target when enqueuing a request. It's optional, but the target is what will receive the loaded placeholder/success/error drawables. Executed requests return an ImageResult which has the success/error drawable. Here's an example: // enqueue val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () val disposable = imageLoader . enqueue ( request ) // execute val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request )","title":"Image Requests"},{"location":"getting_started/#singleton","text":"If you are using the io.coil-kt:coil artifact, you can set the singleton ImageLoader instance by either: Implementing ImageLoaderFactory on your Application class (prefer this method): class MyApplication : Application (), ImageLoaderFactory { override fun newImageLoader (): ImageLoader { return ImageLoader . Builder ( applicationContext ) . crossfade ( true ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( applicationContext )) . build () } . build () } } Or calling Coil.setImageLoader : val imageLoader = ImageLoader . Builder ( context ) . crossfade ( true ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Coil . setImageLoader ( imageLoader ) The singleton ImageLoader can be retrieved using the Context.imageLoader extension function: val imageLoader = context . imageLoader Setting the singleton ImageLoader is optional. If you don't set one, Coil will lazily create an ImageLoader with the default values. If you're using the io.coil-kt:coil-base artifact, you should create your own ImageLoader instance(s) and inject them throughout your app with dependency injection. Read more about dependency injection here . Note If you set a custom OkHttpClient , you must set a cache implementation or the ImageLoader will have no disk cache. A default Coil cache instance can be created using CoilUtils.createDefaultCache .","title":"Singleton"},{"location":"getting_started/#imageview-extension-functions","text":"The io.coil-kt:coil artifact provides a set of type-safe ImageView extension functions. Here's an example for loading a URL into an ImageView : imageView . load ( \"https://www.example.com/image.jpg\" ) The above call is equivalent to: val imageLoader = imageView . context . imageLoader val request = ImageRequest . Builder ( imageView . context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . build () imageLoader . enqueue ( request ) ImageView.load calls can be configured with an optional trailing lambda parameter: imageView . load ( \"https://www.example.com/image.jpg\" ) { crossfade ( true ) placeholder ( R . drawable . image ) transformations ( CircleCropTransformation ()) } See the docs here for more information.","title":"ImageView Extension Functions"},{"location":"getting_started/#supported-data-types","text":"The base data types that are supported by all ImageLoader instances are: String (mapped to a Uri) HttpUrl Uri ( android.resource , content , file , http , and https schemes only) File @DrawableRes Int Drawable Bitmap","title":"Supported Data Types"},{"location":"getting_started/#supported-image-formats","text":"All ImageLoader s support the following non-animated file types: BMP JPEG PNG WebP HEIF (Android 8.0+) Additionally, Coil has extension libraries for the following file types: coil-gif : GIF, animated WebP (Android 9.0+), animated HEIF (Android 11.0+) coil-svg : SVG coil-video : Static video frames from any video codec supported by Android","title":"Supported Image Formats"},{"location":"getting_started/#preloading","text":"To preload an image into memory, enqueue or execute an ImageRequest without a Target : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) // Optional, but setting a ViewSizeResolver will conserve memory by limiting the size the image should be preloaded into memory at. . size ( ViewSizeResolver ( imageView )) . build () imageLoader . enqueue ( request ) To preload a network image only into the disk cache, disable the memory cache for the request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . memoryCachePolicy ( CachePolicy . DISABLED ) . build () imageLoader . enqueue ( request )","title":"Preloading"},{"location":"getting_started/#cancelling-requests","text":"ImageRequest s will be automatically cancelled in the following cases: request.lifecycle reaches the DESTROYED state. request.target is a ViewTarget and its View is detached. Additionally, ImageLoader.enqueue returns a Disposable , which can be used to dispose the request (which cancels it and frees its associated resources): val disposable = imageView . load ( \"https://www.example.com/image.jpg\" ) // Cancel the request. disposable . dispose ()","title":"Cancelling Requests"},{"location":"getting_started/#memory-cache","text":"Each ImageLoader has its own MemoryCache of recently loaded images. To read/write a Bitmap to the memory cache, you need a MemoryCache.Key . There are two ways to get a MemoryCache.Key : Create a MemoryCache.Key using its String constructor: MemoryCache.Key(\"my_cache_key\") Get the MemoryCache.Key from an executed request: // If using the ImageLoader singleton val memoryCacheKey = imageView . metadata . memoryCacheKey // Enqueue val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( imageView ) . listener { _ , metadata -> val memoryCacheKey = metadata . memoryCacheKey } . build () imageLoader . enqueue ( request ) // Execute val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . build () val result = imageLoader . execute ( request ) as SuccessResult val memoryCacheKey = result . metadata . memoryCacheKey Once you have the memory cache key, you can read/write to the memory cache synchronously: // Get val bitmap : Bitmap? = imageLoader . memoryCache [ memoryCacheKey ] // Set imageLoader . memoryCache [ memoryCacheKey ] = bitmap","title":"Memory Cache"},{"location":"gifs/","text":"Gifs \u00b6 Unlike Glide, GIFs are not supported by default. However, Coil has an extension library to support them. To add GIF support, import the extension library: implementation ( \"io.coil-kt:coil-gif:1.3.0\" ) And add the decoders to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { if ( SDK_INT >= 28 ) { add ( ImageDecoderDecoder ( context )) } else { add ( GifDecoder ()) } } . build () And that's it! The ImageLoader will automatically detect any GIFs using their file headers and decode them correctly. To transform the pixel data of each frame of a GIF, see AnimatedTransformation . Note Coil includes two separate decoders to support decoding GIFs. GifDecoder supports all API levels, but is slower. ImageDecoderDecoder is powered by Android's new ImageDecoder API which is only available on API 28 and above. ImageDecoderDecoder is faster than GifDecoder and supports decoding animated WebP images and animated HEIF image sequences.","title":"GIFs"},{"location":"gifs/#gifs","text":"Unlike Glide, GIFs are not supported by default. However, Coil has an extension library to support them. To add GIF support, import the extension library: implementation ( \"io.coil-kt:coil-gif:1.3.0\" ) And add the decoders to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { if ( SDK_INT >= 28 ) { add ( ImageDecoderDecoder ( context )) } else { add ( GifDecoder ()) } } . build () And that's it! The ImageLoader will automatically detect any GIFs using their file headers and decode them correctly. To transform the pixel data of each frame of a GIF, see AnimatedTransformation . Note Coil includes two separate decoders to support decoding GIFs. GifDecoder supports all API levels, but is slower. ImageDecoderDecoder is powered by Android's new ImageDecoder API which is only available on API 28 and above. ImageDecoderDecoder is faster than GifDecoder and supports decoding animated WebP images and animated HEIF image sequences.","title":"Gifs"},{"location":"image_loaders/","text":"Image Loaders \u00b6 ImageLoader s are service objects that execute ImageRequest s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . availableMemoryPercentage ( 0.25 ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, bitmap pool, and network observer. It's recommended, though not required, to call shutdown when you've finished using an image loader. This preemptively frees its memory and cleans up any observers. If you only create and use one ImageLoader , you do not need to shut it down as it will be freed when your app is killed. Caching \u00b6 Each ImageLoader keeps a memory cache of recently decoded Bitmap s as well as a reusable pool of Bitmap s to decode into. ImageLoader s rely on an OkHttpClient to handle disk caching. By default, every ImageLoader is already set up for disk caching and will set a max cache size of between 10-250MB depending on the remaining space on the user's device. However, if you set a custom OkHttpClient , you'll need to add the disk cache yourself. To get a Cache instance that's optimized for Coil, you can use CoilUtils.createDefaultCache . Optionally, you can create your own Cache instance with a different size + location. Here's an example: val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Singleton vs. Dependency Injection \u00b6 Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache and bitmap pool. If you use a dependency injector like Dagger , then you should create a single ImageLoader instance and inject it throughout your app. However, if you'd prefer a singleton the io.coil-kt:coil artifact provides a singleton ImageLoader instance that can be accessed using the Context.imageLoader extension function. Read here for how to initialize the singleton ImageLoader instance. Note Use the io.coil-kt:coil-base artifact if you are using dependency injection. Testing \u00b6 ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could inject a fake ImageLoader implementation which always returns the same Drawable synchronously: val fakeImageLoader = object : ImageLoader { private val disposable = object : Disposable { override val isDisposed get () = true override fun dispose () {} override suspend fun await () {} } override val defaults = DefaultRequestOptions () // Optionally, you can add a custom fake memory cache implementation. override val memoryCache get () = throw UnsupportedOperationException () override val bitmapPool = BitmapPool ( 0 ) override fun enqueue ( request : ImageRequest ): Disposable { // Always call onStart before onSuccess. request . target ?. onStart ( placeholder = ColorDrawable ( Color . BLACK )) request . target ?. onSuccess ( result = ColorDrawable ( Color . BLACK )) return disposable } override suspend fun execute ( request : ImageRequest ): ImageResult { return SuccessResult ( drawable = ColorDrawable ( Color . BLACK ), request = request , metadata = ImageResult . Metadata ( memoryCacheKey = MemoryCache . Key ( \"\" ), isSampled = false , dataSource = DataSource . MEMORY_CACHE , isPlaceholderMemoryCacheKeyPresent = false ) ) } override fun shutdown () {} override fun newBuilder () = ImageLoader . Builder ( context ) } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Image Loaders"},{"location":"image_loaders/#image-loaders","text":"ImageLoader s are service objects that execute ImageRequest s. They handle caching, data fetching, image decoding, request management, bitmap pooling, memory management, and more. New instances can be created and configured using a builder: val imageLoader = ImageLoader . Builder ( context ) . availableMemoryPercentage ( 0.25 ) . crossfade ( true ) . build () Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache, bitmap pool, and network observer. It's recommended, though not required, to call shutdown when you've finished using an image loader. This preemptively frees its memory and cleans up any observers. If you only create and use one ImageLoader , you do not need to shut it down as it will be freed when your app is killed.","title":"Image Loaders"},{"location":"image_loaders/#caching","text":"Each ImageLoader keeps a memory cache of recently decoded Bitmap s as well as a reusable pool of Bitmap s to decode into. ImageLoader s rely on an OkHttpClient to handle disk caching. By default, every ImageLoader is already set up for disk caching and will set a max cache size of between 10-250MB depending on the remaining space on the user's device. However, if you set a custom OkHttpClient , you'll need to add the disk cache yourself. To get a Cache instance that's optimized for Coil, you can use CoilUtils.createDefaultCache . Optionally, you can create your own Cache instance with a different size + location. Here's an example: val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build ()","title":"Caching"},{"location":"image_loaders/#singleton-vs-dependency-injection","text":"Coil performs best when you create a single ImageLoader and share it throughout your app. This is because each ImageLoader has its own memory cache and bitmap pool. If you use a dependency injector like Dagger , then you should create a single ImageLoader instance and inject it throughout your app. However, if you'd prefer a singleton the io.coil-kt:coil artifact provides a singleton ImageLoader instance that can be accessed using the Context.imageLoader extension function. Read here for how to initialize the singleton ImageLoader instance. Note Use the io.coil-kt:coil-base artifact if you are using dependency injection.","title":"Singleton vs. Dependency Injection"},{"location":"image_loaders/#testing","text":"ImageLoader is an interface, which you can replace with a fake implementation. For instance, you could inject a fake ImageLoader implementation which always returns the same Drawable synchronously: val fakeImageLoader = object : ImageLoader { private val disposable = object : Disposable { override val isDisposed get () = true override fun dispose () {} override suspend fun await () {} } override val defaults = DefaultRequestOptions () // Optionally, you can add a custom fake memory cache implementation. override val memoryCache get () = throw UnsupportedOperationException () override val bitmapPool = BitmapPool ( 0 ) override fun enqueue ( request : ImageRequest ): Disposable { // Always call onStart before onSuccess. request . target ?. onStart ( placeholder = ColorDrawable ( Color . BLACK )) request . target ?. onSuccess ( result = ColorDrawable ( Color . BLACK )) return disposable } override suspend fun execute ( request : ImageRequest ): ImageResult { return SuccessResult ( drawable = ColorDrawable ( Color . BLACK ), request = request , metadata = ImageResult . Metadata ( memoryCacheKey = MemoryCache . Key ( \"\" ), isSampled = false , dataSource = DataSource . MEMORY_CACHE , isPlaceholderMemoryCacheKeyPresent = false ) ) } override fun shutdown () {} override fun newBuilder () = ImageLoader . Builder ( context ) } This is perfect for screenshot and instrumentation tests where you want consistent rendering behavior.","title":"Testing"},{"location":"image_pipeline/","text":"Extending the Image Pipeline \u00b6 Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, TIFF, etc.) Fortunately, ImageLoader s support pluggable components to add new cache layers, new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of four main parts: Interceptors , Mappers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( CustomCacheInterceptor ()) add ( ItemMapper ()) add ( CronetFetcher ()) add ( GifDecoder ()) } . build () Interceptors \u00b6 Interceptors allow you to observe, transform, short circuit, or retry requests to an ImageLoader 's image engine. For example, you can add a custom cache layer like so: class CustomCacheInterceptor ( private val context : Context , private val cache : LruCache < String , Drawable > ) : Interceptor { override suspend fun intercept ( chain : Interceptor . Chain ): ImageResult { val value = cache . get ( chain . request . data . toString ()) if ( value != null ) { return SuccessResult ( drawable = value . bitmap . toDrawable ( context ), request = chain . request , metadata = TODO () ) } return chain . proceed ( chain . request ) } } Interceptors are an advanced feature that let you wrap an ImageLoader 's image pipeline with custom logic. Their design is heavily based on OkHttp's Interceptor interface . See Interceptor for more information. Mappers \u00b6 Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to its URL, which will be handled later in the pipeline: class ItemMapper : Mapper < Item , String > { override fun map ( data : Item ) = data . imageUrl } After registering it when building our ImageLoader (see above), we can safely load an Item : val request = ImageRequest . Builder ( context ) . data ( item ) . target ( imageView ) . build () imageLoader . enqueue ( request ) See Mapper for more information. Fetchers \u00b6 Fetchers translate data into either a BufferedSource or a Drawable . See Fetcher for more information. Decoders \u00b6 Decoders read a BufferedSource as input and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information. Note Decoders are responsible for closing the BufferedSource when finished. This allows custom decoders to return a Drawable while still reading the source. This can be useful to support file types such as progressive JPEG where there is incremental information to show.","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#extending-the-image-pipeline","text":"Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, TIFF, etc.) Fortunately, ImageLoader s support pluggable components to add new cache layers, new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of four main parts: Interceptors , Mappers , Fetchers , and Decoders . Custom components must be added to the ImageLoader when constructing it through its ComponentRegistry : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( CustomCacheInterceptor ()) add ( ItemMapper ()) add ( CronetFetcher ()) add ( GifDecoder ()) } . build ()","title":"Extending the Image Pipeline"},{"location":"image_pipeline/#interceptors","text":"Interceptors allow you to observe, transform, short circuit, or retry requests to an ImageLoader 's image engine. For example, you can add a custom cache layer like so: class CustomCacheInterceptor ( private val context : Context , private val cache : LruCache < String , Drawable > ) : Interceptor { override suspend fun intercept ( chain : Interceptor . Chain ): ImageResult { val value = cache . get ( chain . request . data . toString ()) if ( value != null ) { return SuccessResult ( drawable = value . bitmap . toDrawable ( context ), request = chain . request , metadata = TODO () ) } return chain . proceed ( chain . request ) } } Interceptors are an advanced feature that let you wrap an ImageLoader 's image pipeline with custom logic. Their design is heavily based on OkHttp's Interceptor interface . See Interceptor for more information.","title":"Interceptors"},{"location":"image_pipeline/#mappers","text":"Mappers allow you to add support for custom data types. For instance, say we get this model from our server: data class Item ( val id : Int , val imageUrl : String , val price : Int , val weight : Double ) We could write a custom mapper to map it to its URL, which will be handled later in the pipeline: class ItemMapper : Mapper < Item , String > { override fun map ( data : Item ) = data . imageUrl } After registering it when building our ImageLoader (see above), we can safely load an Item : val request = ImageRequest . Builder ( context ) . data ( item ) . target ( imageView ) . build () imageLoader . enqueue ( request ) See Mapper for more information.","title":"Mappers"},{"location":"image_pipeline/#fetchers","text":"Fetchers translate data into either a BufferedSource or a Drawable . See Fetcher for more information.","title":"Fetchers"},{"location":"image_pipeline/#decoders","text":"Decoders read a BufferedSource as input and return a Drawable . Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.). See Decoder for more information. Note Decoders are responsible for closing the BufferedSource when finished. This allows custom decoders to return a Drawable while still reading the source. This can be useful to support file types such as progressive JPEG where there is incremental information to show.","title":"Decoders"},{"location":"image_requests/","text":"Image Requests \u00b6 ImageRequest s are value objects that provide all the necessary information for an ImageLoader to load an image. ImageRequest s can be created using a builder: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build () Once you've created a request pass it to an ImageLoader to enqueue/execute it: imageLoader . enqueue ( request ) See the API documentation for more information.","title":"Image Requests"},{"location":"image_requests/#image-requests","text":"ImageRequest s are value objects that provide all the necessary information for an ImageLoader to load an image. ImageRequest s can be created using a builder: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build () Once you've created a request pass it to an ImageLoader to enqueue/execute it: imageLoader . enqueue ( request ) See the API documentation for more information.","title":"Image Requests"},{"location":"java_compatibility/","text":"Java Compatibility \u00b6 Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Importantly, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. Despite these limitations, most of Coil's API is Java compatible. The Context.imageLoader extension function should not be used from Java. Instead, you can get the singleton ImageLoader using: ImageLoader imageLoader = Coil . imageLoader ( context ) The syntax to enqueue an ImageRequest is almost the same in Java and Kotlin: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . enqueue ( request ) Note ImageView.load extension functions cannot be used from Java. Use the ImageRequest.Builder API instead. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to use the ImageLoader.executeBlocking extension function which can be called from Java like so: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaders . executeBlocking ( imageLoader , request ). getDrawable (); Note ImageLoaders.executeBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"java_compatibility/#java-compatibility","text":"Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java. Importantly, suspend functions cannot be implemented in Java. This means custom Transformations , Size Resolvers , Fetchers , and Decoders must be implemented in Kotlin. Despite these limitations, most of Coil's API is Java compatible. The Context.imageLoader extension function should not be used from Java. Instead, you can get the singleton ImageLoader using: ImageLoader imageLoader = Coil . imageLoader ( context ) The syntax to enqueue an ImageRequest is almost the same in Java and Kotlin: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . crossfade ( true ) . target ( imageView ) . build (); imageLoader . enqueue ( request ) Note ImageView.load extension functions cannot be used from Java. Use the ImageRequest.Builder API instead. suspend functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to use the ImageLoader.executeBlocking extension function which can be called from Java like so: ImageRequest request = new ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . size ( 1080 , 1920 ) . build (); Drawable drawable = ImageLoaders . executeBlocking ( imageLoader , request ). getDrawable (); Note ImageLoaders.executeBlocking will block the current thread instead of suspending. Do not call this from the main thread.","title":"Java Compatibility"},{"location":"migrating/","text":"Migrating from Glide/Picasso \u00b6 Here are a few examples of how to migrate Glide/Picasso calls into Coil calls: Basic Usage \u00b6 // Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url ) Custom Requests \u00b6 imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (automatically detects the scale type) imageView . load ( url ) { placeholder ( placeholder ) } Non-View Targets \u00b6 // Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget < Drawable > () { override fun onResourceReady ( resource : Drawable , transition : Transition < Drawable > ) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable?) { // Handle the placeholder drawable. } }) // Coil val request = ImageRequest . Builder ( context ) . data ( url ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () context . imageLoader . enqueue ( request ) Background Thread \u00b6 // Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current coroutine; non-blocking and thread safe) val request = ImageRequest . Builder ( context ) . data ( url ) . size ( width , height ) . build () val drawable = context . imageLoader . execute ( request ). drawable","title":"Migrating from Glide/Picasso"},{"location":"migrating/#migrating-from-glidepicasso","text":"Here are a few examples of how to migrate Glide/Picasso calls into Coil calls:","title":"Migrating from Glide/Picasso"},{"location":"migrating/#basic-usage","text":"// Glide Glide . with ( context ) . load ( url ) . into ( imageView ) // Picasso Picasso . get () . load ( url ) . into ( imageView ) // Coil imageView . load ( url )","title":"Basic Usage"},{"location":"migrating/#custom-requests","text":"imageView . scaleType = ImageView . ScaleType . FIT_CENTER // Glide Glide . with ( context ) . load ( url ) . placeholder ( placeholder ) . fitCenter () . into ( imageView ) // Picasso Picasso . get () . load ( url ) . placeholder ( placeholder ) . fit () . into ( imageView ) // Coil (automatically detects the scale type) imageView . load ( url ) { placeholder ( placeholder ) }","title":"Custom Requests"},{"location":"migrating/#non-view-targets","text":"// Glide (has optional callbacks for start and error) Glide . with ( context ) . load ( url ) . into ( object : CustomTarget < Drawable > () { override fun onResourceReady ( resource : Drawable , transition : Transition < Drawable > ) { // Handle the successful result. } override fun onLoadCleared ( placeholder : Drawable ) { // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain. } }) // Picasso Picasso . get () . load ( url ) . into ( object : BitmapTarget { override fun onBitmapLoaded ( bitmap : Bitmap , from : Picasso . LoadedFrom ) { // Handle the successful result. } override fun onBitmapFailed ( e : Exception , errorDrawable : Drawable?) { // Handle the error drawable. } override fun onPrepareLoad ( placeHolderDrawable : Drawable?) { // Handle the placeholder drawable. } }) // Coil val request = ImageRequest . Builder ( context ) . data ( url ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () context . imageLoader . enqueue ( request )","title":"Non-View Targets"},{"location":"migrating/#background-thread","text":"// Glide (blocks the current thread; must not be called from the main thread) val drawable = Glide . with ( context ) . load ( url ) . submit ( width , height ) . get () // Picasso (blocks the current thread; must not be called from the main thread) val drawable = Picasso . get () . load ( url ) . resize ( width , height ) . get () // Coil (suspends the current coroutine; non-blocking and thread safe) val request = ImageRequest . Builder ( context ) . data ( url ) . size ( width , height ) . build () val drawable = context . imageLoader . execute ( request ). drawable","title":"Background Thread"},{"location":"recipes/","text":"Recipes \u00b6 This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fit your exact requirements, but it should hopefully give you a push in the right direction! See a common use case that isn't covered? Feel free to submit a PR with a new section. Palette \u00b6 Palette allows you to exact prominent colors from an image. To create a Palette , you'll need access to an image's Bitmap . This can be done in a number of ways: Enqueue \u00b6 You can get access to an image's bitmap by setting a Target and enqueuing ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . target { drawable -> // Generate the Palette on a background thread. val task = Palette . Builder ( drawable . toBitmap ()). generate { palette -> // Consume the palette. } } . build () val disposable = imageLoader . enqueue ( request ) Execute \u00b6 You can also execute an ImageRequest , which returns the drawable imperatively: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . build () val drawable = ( imageLoader . execute ( request ) as SuccessResult ). drawable val palette = coroutineScope { launch ( Dispatchers . IO ) { Palette . Builder ( drawable . toBitmap ()). generate () } } Transition \u00b6 There may be cases where you want to load an image into a PoolableViewTarget (e.g. ImageViewTarget ) while extracting the image's colors in parallel. For these cases, you can use a custom Transition to get access to the underlying bitmap: class PaletteTransition ( private val delegate : Transition?, private val onGenerated : ( Palette ) -> Unit ) : Transition { override suspend fun transition ( target : TransitionTarget , result : RequestResult ) { // Execute the delegate transition. val delegateJob = delegate ?. let { delegate -> coroutineScope { launch ( Dispatchers . Main . immediate ) { delegate . transition ( target , result ) } } } // Compute the palette on a background thread. if ( result is SuccessResult ) { val bitmap = result . drawable . toBitmap () val palette = withContext ( Dispatchers . IO ) { Palette . Builder ( bitmap ). generate () } onGenerated ( palette ) } delegateJob ?. join () } } // ImageRequest val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . transition ( PaletteTransition ( CrossfadeTransition ()) { palette -> // Consume the palette. }) . target ( imageView ) . build () imageLoader . enqueue ( request ) // ImageView.load imageView . load ( \"https://www.example.com/image.jpg\" ) { allowHardware ( false ) transition ( PaletteTransition ( CrossfadeTransition ()) { palette -> // Consume the palette. }) } Note You should not pass the drawable outside the scope of Transition.transition . This can cause the drawable's underlying bitmap to be pooled while it is still in use, which can result in rendering issues and crashes. Using a custom OkHttpClient \u00b6 Coil uses OkHttp for all its networking operations. You can specify a custom OkHttpClient when creating your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) // Create the OkHttpClient inside a lambda so it will be initialized lazily on a background thread. . okHttpClient { OkHttpClient . Builder () // You need to set the cache for disk caching to work. . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Note If you already have a built OkHttpClient , use newBuilder() to build a new client that shares resources with the original. Also, it's recommended to use a separate Cache instance for your Coil OkHttpClient . Image files can quickly evict more important cached network responses if they share the same cache. Headers \u00b6 Headers can be added to your image requests in one of two ways. You can set headers for a single request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . setHeader ( \"Cache-Control\" , \"max-age=31536000,public\" ) . target ( imageView ) . build () imageLoader . execute ( request ) Or you can create an OkHttp Interceptor that sets headers for every request executed by your ImageLoader : class ResponseHeaderInterceptor ( private val name : String , private val value : String ) : Interceptor { override fun intercept ( chain : Interceptor . Chain ): Response { val response = chain . proceed ( chain . request ()) return response . newBuilder (). header ( name , value ). build () } } val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) // This header will be added to every image request. . addNetworkInterceptor ( ResponseHeaderInterceptor ( \"Cache-Control\" , \"max-age=31536000,public\" )) . build () } . build () Using a Memory Cache Key as a Placeholder \u00b6 Using a previous request's MemoryCache.Key as a placeholder for a subsequent request can be useful if the two images are the same, though loaded at different sizes. For instance, if the first request loads the image at 100x100 and the second request loads the image at 500x500, we can use the first image as a synchronous placeholder for the second request. Here's what this effect looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect. To achieve this effect, use the MemoryCache.Key of the first request as the ImageRequest.placeholderMemoryCacheKey of the second request. Here's an example: // First request listImageView . load ( \"https://www.example.com/image.jpg\" ) // Second request detailImageView . load ( \"https://www.example.com/image.jpg\" ) { placeholderMemoryCacheKey ( listImageView . metadata . memoryCacheKey ) } Note Previous versions of Coil would attempt to set up this effect automatically . This required executing parts of the image pipeline synchronously on the main thread and it was ultimately removed in version 0.12.0 . Shared Element Transitions \u00b6 Shared element transitions allow you to animate between Activities and Fragments . Here are some recommendations on how to get them to work with Coil: Shared element transitions are incompatible with hardware bitmaps. You should set allowHardware(false) to disable hardware bitmaps for both the ImageView you are animating from and the view you are animating to. If you don't, the transition will throw an java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps exception. Use the MemoryCache.Key of the start image as the placeholderMemoryCacheKey for the end image. This ensures that the start image is used as the placeholder for the end image, which results in a smooth transition with no white flashes if the image is in the memory cache. Use ChangeImageTransform and ChangeBounds together for optimal results. Remote Views \u00b6 Coil does not provide a Target for RemoteViews out of the box, however you can create one like so: class RemoteViewsTarget ( private val context : Context , private val componentName : ComponentName , private val remoteViews : RemoteViews , @IdRes private val imageViewResId : Int ) : Target { override fun onStart ( placeholder : Drawable?) = setDrawable ( placeholder ) override fun onError ( error : Drawable?) = setDrawable ( error ) override fun onSuccess ( result : Drawable ) = setDrawable ( result ) private fun setDrawable ( drawable : Drawable?) { remoteViews . setImageViewBitmap ( imageViewResId , drawable ?. toBitmap ()) AppWidgetManager . getInstance ( context ). updateAppWidget ( componentName , remoteViews ) } } Then enqueue / execute the request like normal: val target = RemoteViewsTarget (...) val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( target ) . build () imageLoader . enqueue ( request )","title":"Recipes"},{"location":"recipes/#recipes","text":"This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fit your exact requirements, but it should hopefully give you a push in the right direction! See a common use case that isn't covered? Feel free to submit a PR with a new section.","title":"Recipes"},{"location":"recipes/#palette","text":"Palette allows you to exact prominent colors from an image. To create a Palette , you'll need access to an image's Bitmap . This can be done in a number of ways:","title":"Palette"},{"location":"recipes/#enqueue","text":"You can get access to an image's bitmap by setting a Target and enqueuing ImageRequest : val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . target { drawable -> // Generate the Palette on a background thread. val task = Palette . Builder ( drawable . toBitmap ()). generate { palette -> // Consume the palette. } } . build () val disposable = imageLoader . enqueue ( request )","title":"Enqueue"},{"location":"recipes/#execute","text":"You can also execute an ImageRequest , which returns the drawable imperatively: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . build () val drawable = ( imageLoader . execute ( request ) as SuccessResult ). drawable val palette = coroutineScope { launch ( Dispatchers . IO ) { Palette . Builder ( drawable . toBitmap ()). generate () } }","title":"Execute"},{"location":"recipes/#transition","text":"There may be cases where you want to load an image into a PoolableViewTarget (e.g. ImageViewTarget ) while extracting the image's colors in parallel. For these cases, you can use a custom Transition to get access to the underlying bitmap: class PaletteTransition ( private val delegate : Transition?, private val onGenerated : ( Palette ) -> Unit ) : Transition { override suspend fun transition ( target : TransitionTarget , result : RequestResult ) { // Execute the delegate transition. val delegateJob = delegate ?. let { delegate -> coroutineScope { launch ( Dispatchers . Main . immediate ) { delegate . transition ( target , result ) } } } // Compute the palette on a background thread. if ( result is SuccessResult ) { val bitmap = result . drawable . toBitmap () val palette = withContext ( Dispatchers . IO ) { Palette . Builder ( bitmap ). generate () } onGenerated ( palette ) } delegateJob ?. join () } } // ImageRequest val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . allowHardware ( false ) // Disable hardware bitmaps. . transition ( PaletteTransition ( CrossfadeTransition ()) { palette -> // Consume the palette. }) . target ( imageView ) . build () imageLoader . enqueue ( request ) // ImageView.load imageView . load ( \"https://www.example.com/image.jpg\" ) { allowHardware ( false ) transition ( PaletteTransition ( CrossfadeTransition ()) { palette -> // Consume the palette. }) } Note You should not pass the drawable outside the scope of Transition.transition . This can cause the drawable's underlying bitmap to be pooled while it is still in use, which can result in rendering issues and crashes.","title":"Transition"},{"location":"recipes/#using-a-custom-okhttpclient","text":"Coil uses OkHttp for all its networking operations. You can specify a custom OkHttpClient when creating your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) // Create the OkHttpClient inside a lambda so it will be initialized lazily on a background thread. . okHttpClient { OkHttpClient . Builder () // You need to set the cache for disk caching to work. . cache ( CoilUtils . createDefaultCache ( context )) . build () } . build () Note If you already have a built OkHttpClient , use newBuilder() to build a new client that shares resources with the original. Also, it's recommended to use a separate Cache instance for your Coil OkHttpClient . Image files can quickly evict more important cached network responses if they share the same cache.","title":"Using a custom OkHttpClient"},{"location":"recipes/#headers","text":"Headers can be added to your image requests in one of two ways. You can set headers for a single request: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . setHeader ( \"Cache-Control\" , \"max-age=31536000,public\" ) . target ( imageView ) . build () imageLoader . execute ( request ) Or you can create an OkHttp Interceptor that sets headers for every request executed by your ImageLoader : class ResponseHeaderInterceptor ( private val name : String , private val value : String ) : Interceptor { override fun intercept ( chain : Interceptor . Chain ): Response { val response = chain . proceed ( chain . request ()) return response . newBuilder (). header ( name , value ). build () } } val imageLoader = ImageLoader . Builder ( context ) . okHttpClient { OkHttpClient . Builder () . cache ( CoilUtils . createDefaultCache ( context )) // This header will be added to every image request. . addNetworkInterceptor ( ResponseHeaderInterceptor ( \"Cache-Control\" , \"max-age=31536000,public\" )) . build () } . build ()","title":"Headers"},{"location":"recipes/#using-a-memory-cache-key-as-a-placeholder","text":"Using a previous request's MemoryCache.Key as a placeholder for a subsequent request can be useful if the two images are the same, though loaded at different sizes. For instance, if the first request loads the image at 100x100 and the second request loads the image at 500x500, we can use the first image as a synchronous placeholder for the second request. Here's what this effect looks like in the sample app: Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect. To achieve this effect, use the MemoryCache.Key of the first request as the ImageRequest.placeholderMemoryCacheKey of the second request. Here's an example: // First request listImageView . load ( \"https://www.example.com/image.jpg\" ) // Second request detailImageView . load ( \"https://www.example.com/image.jpg\" ) { placeholderMemoryCacheKey ( listImageView . metadata . memoryCacheKey ) } Note Previous versions of Coil would attempt to set up this effect automatically . This required executing parts of the image pipeline synchronously on the main thread and it was ultimately removed in version 0.12.0 .","title":"Using a Memory Cache Key as a Placeholder"},{"location":"recipes/#shared-element-transitions","text":"Shared element transitions allow you to animate between Activities and Fragments . Here are some recommendations on how to get them to work with Coil: Shared element transitions are incompatible with hardware bitmaps. You should set allowHardware(false) to disable hardware bitmaps for both the ImageView you are animating from and the view you are animating to. If you don't, the transition will throw an java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps exception. Use the MemoryCache.Key of the start image as the placeholderMemoryCacheKey for the end image. This ensures that the start image is used as the placeholder for the end image, which results in a smooth transition with no white flashes if the image is in the memory cache. Use ChangeImageTransform and ChangeBounds together for optimal results.","title":"Shared Element Transitions"},{"location":"recipes/#remote-views","text":"Coil does not provide a Target for RemoteViews out of the box, however you can create one like so: class RemoteViewsTarget ( private val context : Context , private val componentName : ComponentName , private val remoteViews : RemoteViews , @IdRes private val imageViewResId : Int ) : Target { override fun onStart ( placeholder : Drawable?) = setDrawable ( placeholder ) override fun onError ( error : Drawable?) = setDrawable ( error ) override fun onSuccess ( result : Drawable ) = setDrawable ( result ) private fun setDrawable ( drawable : Drawable?) { remoteViews . setImageViewBitmap ( imageViewResId , drawable ?. toBitmap ()) AppWidgetManager . getInstance ( context ). updateAppWidget ( componentName , remoteViews ) } } Then enqueue / execute the request like normal: val target = RemoteViewsTarget (...) val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( target ) . build () imageLoader . enqueue ( request )","title":"Remote Views"},{"location":"svgs/","text":"SVGs \u00b6 To add SVG support, import the extension library: implementation ( \"io.coil-kt:coil-svg:1.3.0\" ) And add the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( SvgDecoder ( context )) } . build () The ImageLoader will automatically detect and decode any SVGs. Coil detects SVGs by looking for the <svg marker in the first 1 KB of the file, which should cover most cases. If the SVG is not automatically detected, you can set the Decoder explicitly to SvgDecoder for the request.","title":"SVGs"},{"location":"svgs/#svgs","text":"To add SVG support, import the extension library: implementation ( \"io.coil-kt:coil-svg:1.3.0\" ) And add the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( SvgDecoder ( context )) } . build () The ImageLoader will automatically detect and decode any SVGs. Coil detects SVGs by looking for the <svg marker in the first 1 KB of the file, which should cover most cases. If the SVG is not automatically detected, you can set the Decoder explicitly to SvgDecoder for the request.","title":"SVGs"},{"location":"targets/","text":"Targets \u00b6 Targets receive the result of an ImageRequest . They often act as \"view adapters\" by taking the placeholder/error/success drawables and applying them to a View (e.g. ImageViewTarget ). Here's the easiest way to create a custom target: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . enqueue ( request ) There are 3 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle. PoolableViewTarget : A ViewTarget that supports bitmap pooling . This has performance benefits, however it comes with several strict behavior requirements. Read the docs for more information.","title":"Targets"},{"location":"targets/#targets","text":"Targets receive the result of an ImageRequest . They often act as \"view adapters\" by taking the placeholder/error/success drawables and applying them to a View (e.g. ImageViewTarget ). Here's the easiest way to create a custom target: val request = ImageRequest . Builder ( context ) . data ( \"https://www.example.com/image.jpg\" ) . target ( onStart = { placeholder -> // Handle the placeholder drawable. }, onSuccess = { result -> // Handle the successful result. }, onError = { error -> // Handle the error drawable. } ) . build () imageLoader . enqueue ( request ) There are 3 types of targets: Target : The base target class. Prefer this if the image request isn't tied to a View . ViewTarget : A target with an associated View . Prefer this if the request sets the placeholder/error/success Drawables on a View . Using ViewTarget also binds the request to the View 's lifecycle. PoolableViewTarget : A ViewTarget that supports bitmap pooling . This has performance benefits, however it comes with several strict behavior requirements. Read the docs for more information.","title":"Targets"},{"location":"transformations/","text":"Transformations \u00b6 Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 4 transformations: blur , circle crop , and grayscale , and rounded corners . Transformations only modify the pixel data for static images. Adding a transformation to an ImageRequest that produces an animated image will convert it to a static image so the transformation can be applied. To transform the pixel data of each frame of an animated image, see AnimatedTransformation . See the API doc for more information. Note If the Drawable returned by the image pipeline is not a BitmapDrawable , it will be converted to one. This will cause animated drawables to only draw the first frame of their animation.","title":"Transformations"},{"location":"transformations/#transformations","text":"Transformations allow you to modify the pixel data of an image before the Drawable is returned from the request. By default, Coil comes packaged with 4 transformations: blur , circle crop , and grayscale , and rounded corners . Transformations only modify the pixel data for static images. Adding a transformation to an ImageRequest that produces an animated image will convert it to a static image so the transformation can be applied. To transform the pixel data of each frame of an animated image, see AnimatedTransformation . See the API doc for more information. Note If the Drawable returned by the image pipeline is not a BitmapDrawable , it will be converted to one. This will cause animated drawables to only draw the first frame of their animation.","title":"Transformations"},{"location":"transitions/","text":"Transitions \u00b6 Transitions allow you to animate setting the result of an image request on a Target . Both ImageLoader and ImageRequest builders accept a Transition . Transitions allow you to control how the sucess/error drawable is set on the Target . This allows you to animate the target's view or wrap the input drawable. By default, Coil comes packaged with 2 transitions: CrossfadeTransition which crossfades from the current drawable to the success/error drawable. Transition.NONE which sets the drawable on the Target immediately without animating. Take a look at the CrossfadeTransition source code for an example of how to write a custom Transition . See the API doc for more information.","title":"Transitions"},{"location":"transitions/#transitions","text":"Transitions allow you to animate setting the result of an image request on a Target . Both ImageLoader and ImageRequest builders accept a Transition . Transitions allow you to control how the sucess/error drawable is set on the Target . This allows you to animate the target's view or wrap the input drawable. By default, Coil comes packaged with 2 transitions: CrossfadeTransition which crossfades from the current drawable to the success/error drawable. Transition.NONE which sets the drawable on the Target immediately without animating. Take a look at the CrossfadeTransition source code for an example of how to write a custom Transition . See the API doc for more information.","title":"Transitions"},{"location":"videos/","text":"Video Frames \u00b6 To add video frame support, import the extension library: implementation ( \"io.coil-kt:coil-video:1.3.0\" ) And add the two fetchers and the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( VideoFrameFileFetcher ()) add ( VideoFrameUriFetcher ()) add ( VideoFrameDecoder ()) } . build () VideoFrameDecoder handles all data sources, but creates a temporary file on disk to decode the source. VideoFrameFileFetcher and VideoFrameUriFetcher don't create a temporary file, but only work for File s and local Uri s respectively. Registering all 3 components ensures that VideoFrameFileFetcher and VideoFrameUriFetcher are automatically used when appropriate and VideoFrameDecoder is used as a fallback. To specify the time code of the frame to extract from a video, use videoFrameMillis or videoFrameMicros : imageView . load ( File ( \"/path/to/video.mp4\" )) { videoFrameMillis ( 1000 ) } If a frame time isn't specified, the first frame of the video is decoded. The ImageLoader will automatically detect any videos and extract their frames if the request's filename/URI ends with a valid video extension . If it does not, you can set the Fetcher explicitly for the request.","title":"Video Frames"},{"location":"videos/#video-frames","text":"To add video frame support, import the extension library: implementation ( \"io.coil-kt:coil-video:1.3.0\" ) And add the two fetchers and the decoder to your component registry when constructing your ImageLoader : val imageLoader = ImageLoader . Builder ( context ) . componentRegistry { add ( VideoFrameFileFetcher ()) add ( VideoFrameUriFetcher ()) add ( VideoFrameDecoder ()) } . build () VideoFrameDecoder handles all data sources, but creates a temporary file on disk to decode the source. VideoFrameFileFetcher and VideoFrameUriFetcher don't create a temporary file, but only work for File s and local Uri s respectively. Registering all 3 components ensures that VideoFrameFileFetcher and VideoFrameUriFetcher are automatically used when appropriate and VideoFrameDecoder is used as a fallback. To specify the time code of the frame to extract from a video, use videoFrameMillis or videoFrameMicros : imageView . load ( File ( \"/path/to/video.mp4\" )) { videoFrameMillis ( 1000 ) } If a frame time isn't specified, the first frame of the video is decoded. The ImageLoader will automatically detect any videos and extract their frames if the request's filename/URI ends with a valid video extension . If it does not, you can set the Fetcher explicitly for the request.","title":"Video Frames"}]}